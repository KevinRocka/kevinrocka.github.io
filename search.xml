<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JNI 开发一般流程</title>
      <link href="/home/2018/05/03/cppclass/"/>
      <url>/home/2018/05/03/cppclass/</url>
      <content type="html"><![CDATA[<blockquote><p>C++ 的类型转换</p></blockquote><p>* </p>]]></content>
      
      <categories>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
            <tag> JNI </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JNI 开发一般流程</title>
      <link href="/home/2018/05/02/jni1/"/>
      <url>/home/2018/05/02/jni1/</url>
      <content type="html"><![CDATA[<blockquote><p>JNI(Java Native Interface)，Java 和C/C++ 相互调用的一套API，教程相对简单，入门系列。</p></blockquote><h2 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h2><ol><li>编写native方法</li><li>javah命令，生成.h头文件</li><li>复制.h头文件到cpp工程中，复制JDK里面的jni.h和jni_md.h文件到工程中</li><li>实现.h头文件中声明的函数</li><li>生成dll文件给Java调用</li><li>配置动态库给环境变量</li></ol><h3 id="1-编写native方法"><a href="#1-编写native方法" class="headerlink" title="1.编写native方法"></a>1.编写native方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JniTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键字native方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> String <span class="title">getStringFromC</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-生成头文件"><a href="#2-生成头文件" class="headerlink" title="2.生成头文件"></a>2.生成头文件</h3><p>使用javah命令生成.h头文件，头文件代码自动生成。规则：(C的函数名称:Java_完整类名_函数名)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_jni_JniTest */</span><br><span class="line">#ifndef _Included_com_jni_JniTest#define _Included_com_jni_JniTest#ifdef __cplusplusextern "C" &#123;#endif/* * Class:     com_jni_JniTest * Method:    getStringFromC * Signature: ()V */JNIEXPORT jstring JNICALL Java_com_jni_JniTest_getStringFromC  (JNIEnv *, jclass);#ifdef __cplusplus&#125;#endif#endif</span><br></pre></td></tr></table></figure><p>####生成头文件可能遇到的问题</p><ul><li><p>使用javah命令提示找不到类文件</p><p>  我的工作路径是C:\Users\Administarator\Desktop\JniStudy\java_jni，下面就是src和bin，不要直接进入src目录使用javah命令，正确的命令行应该是：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -classpath bin -d jni com.jni.JniTest</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-复制头文件"><a href="#3-复制头文件" class="headerlink" title="3.复制头文件"></a>3.复制头文件</h3><p>准备头文件，头文件有刚刚生成的.h文件以及拷贝以下路径的.h头文件。路径分别为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JDK路径\include\win32\jni_md.h</span><br><span class="line">JDK路径\include\jni.h</span><br></pre></td></tr></table></figure><p>然后在Visual Studio使用添加项来添加头文件，如果还有报错，<br>将生成的头文件.h的#include &lt;jni.h&gt;改为#include “jni.h”</p><h3 id="4-实现-h头文件中的函数"><a href="#4-实现-h头文件中的函数" class="headerlink" title="4.实现.h头文件中的函数"></a>4.实现.h头文件中的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"con_jni_JniTest.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数实现，拷贝.h方法声明，补充参数变量</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_jni_JniTest_getStringFromC</span><br><span class="line">(JNIEnv *env, jclass jcls)&#123;</span><br><span class="line"><span class="comment">//将C的字符串转换为一个Java的字符串</span><span class="keyword">return</span> (*env)-&gt;NewStringUTF(env,<span class="string">"Hello JNI!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-生成dll动态库给java调用"><a href="#5-生成dll动态库给java调用" class="headerlink" title="5.生成dll动态库给java调用"></a>5.生成dll动态库给java调用</h3><p>右键Visual studio项目 -&gt; 属性 -&gt; 配置类型(动态库dll)，然后生成解决方案。</p><p>为什么是dll呢，windows下，使用dll，如果是在android下，就要使用.so。dll动态库生成了之后，要在环境变量中配置动态库的路径，不然eclipse找不到动态库，配置了之后，要重启eclipse。</p><h3 id="6-加载动态库"><a href="#6-加载动态库" class="headerlink" title="6.加载动态库"></a>6.加载动态库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JniTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键字native方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> String <span class="title">getStringFromC</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.print(getStringFromC());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.loadLibrary(<span class="string">"jni_study"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后当然是输出  Hello JNI!</p><h2 id="JNIEnv"><a href="#JNIEnv" class="headerlink" title="JNIEnv"></a>JNIEnv</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jstring JNICALL Java_com_jni_JniTest_getStringFromC</span><br><span class="line">(JNIEnv *env, jclass jcls)&#123;</span><br><span class="line"><span class="comment">//将C的字符串转换为一个Java的字符串</span><span class="keyword">return</span> (*env)-&gt;NewStringUTF(env,<span class="string">"Hello JNI!"</span>);</span><br><span class="line"><span class="comment">//将C++ 的字符串转换为一个Java的字符串</span></span><br><span class="line"><span class="keyword">return</span> env -&gt; NewStringUTF(<span class="string">"Hello JNI!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">JNINativeInterface_</span>;</span><span class="class"><span class="keyword">struct</span> <span class="title">JNIEnv_</span>;</span><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span><span class="keyword">typedef</span> JNIEnv_ JNIEnv;<span class="meta">#<span class="meta-keyword">else</span></span><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNINativeInterface_</span> *<span class="title">JNIEnv</span>;</span><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在C和C++中env的使用方式不相同，并且他们的定义也不相同。在C中，JNIEnv是一个结构体指针别名，env是一个二级指针；在C++中，JNIEnv是一个结构体别名，env是一个一级指针。函数执行过程中，需要JNIEnv，C++为什么没有传入，因为有this可以拿到。C++只是对C的那一套做了一层封装。</p>]]></content>
      
      <categories>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
            <tag> JNI </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手动做一套自己的RockaIOC</title>
      <link href="/home/2017/11/02/android_rocka_ioc/"/>
      <url>/home/2017/11/02/android_rocka_ioc/</url>
      <content type="html"><![CDATA[<blockquote><p>ButterKnife，XUtils，RockaIOC !</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP(Aspect Oriented Programming 面向切面编程)技术是建立在JAVA反射和动态代理的基础上的。调用者直接调用的其实AOP容器动态生成的代理对象，再由代理对象调用目标对象完成原始的业务逻辑。</p><ul><li>处理核心业务的时候难免会遇到以前相同逻辑的业务处理(Android 动态申请危险权限，Android 网络监测等)这个时候比较常用的就是AOP来进行处理了。</li></ul><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC(Inversion of Control 控制反转)即让调用类对某一接口具体实现类的选择控制权从调用类中移除交给第三方。换一种说法那就是依赖注入即调用类对某一接口实现类的依赖关系由第三方(容器)注入，以移除调用类对某一接口实现类的依赖。</p><ul><li>注入方式可以分为三种：构造函数注入、属性注入和接口注入、</li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>自定义注解比较简单，简单解释下就是，注解就像是一种标记，加了注解就像是打了标记，程序可以利用JAVA 的反射机制来了解你的类及各种元素上的标记，在针对不同标记来做对应的事。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RUNTIME 运行时检测，CLASS 编译时， SOURCE 源码资源的时候</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">// FIELD 注解只能放在属性上，METHOD 方法上，TYPE 类上，CONSTRUCTOR 构造方法上</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EventViewById &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。 反射是java中一种强大的工具，能够使我们很方便的创建灵活的代码，这些代码可以再运行时装配，无需在组件之间进行源代码链接，反射使用不当会成本很高。</p><ul><li>API在：package java.lang.reflect</li><li>反射简单用法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反射获取属性</span></span><br><span class="line">Class clazz = object.getClass();</span><br><span class="line">Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射获取方法</span></span><br><span class="line">Class clazz = object.getClass();</span><br><span class="line">Method[] methods = clazz.getDeclaredMethods();</span><br></pre></td></tr></table></figure><h2 id="常见IOC框架"><a href="#常见IOC框架" class="headerlink" title="常见IOC框架"></a>常见IOC框架</h2><h3 id="XUtils-xutils-3-5-0"><a href="#XUtils-xutils-3-5-0" class="headerlink" title="XUtils(xutils:3.5.0)"></a>XUtils(xutils:3.5.0)</h3><p>源码解析：</p><p>1.单例模式实例化 ViewInjectorImpl.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Activity或者View中注入Activity实例或者View实例</span></span><br><span class="line"><span class="comment">//x是他的任务控制中心，通过单例进行初始化</span></span><br><span class="line">x.view().inject(<span class="keyword">this</span>); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewInjector <span class="title">view</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Ext.viewInjector == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ViewInjectorImpl.registerInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Ext.viewInjector;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> ViewInjectorImpl();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x.Ext.setViewInjector(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.注入Object，通过反射拿到注解，并且拿到注解的值，在设置到属性或者方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ConstantConditions"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectObject</span><span class="params">(Object handler, Class&lt;?&gt; handlerType, ViewFinder finder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlerType == <span class="keyword">null</span> || IGNORED.contains(handlerType)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从父类到子类递归</span></span><br><span class="line">        injectObject(handler, handlerType.getSuperclass(), finder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inject view</span></span><br><span class="line">        Field[] fields = handlerType.getDeclaredFields();</span><br><span class="line">        <span class="keyword">if</span> (fields != <span class="keyword">null</span> &amp;&amp; fields.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line"></span><br><span class="line">                Class&lt;?&gt; fieldType = field.getType();</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">/* 不注入静态字段 */</span>     Modifier.isStatic(field.getModifiers()) ||</span><br><span class="line">                <span class="comment">/* 不注入final字段 */</span>    Modifier.isFinal(field.getModifiers()) ||</span><br><span class="line">                <span class="comment">/* 不注入基本类型字段 */</span>  fieldType.isPrimitive() ||</span><br><span class="line">                <span class="comment">/* 不注入数组类型字段 */</span>  fieldType.isArray()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ViewInject viewInject = field.getAnnotation(ViewInject.class);</span><br><span class="line">                <span class="keyword">if</span> (viewInject != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        View view = finder.findViewById(viewInject.value(), viewInject.parentId());</span><br><span class="line">                        <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//可以操作所有修饰符</span></span><br><span class="line">                            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                            <span class="comment">//反射注入属性</span></span><br><span class="line">                            field.set(handler, view);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Invalid @ViewInject for "</span></span><br><span class="line">                                    + handlerType.getSimpleName() + <span class="string">"."</span> + field.getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        LogUtil.e(ex.getMessage(), ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end inject view</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// inject event</span></span><br><span class="line">        Method[] methods = handlerType.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())</span><br><span class="line">                        || !Modifier.isPrivate(method.getModifiers())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//检查当前方法是否是event注解的方法</span></span><br><span class="line">                Event event = method.getAnnotation(Event.class);</span><br><span class="line">                <span class="keyword">if</span> (event != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// id参数</span></span><br><span class="line">                        <span class="keyword">int</span>[] values = event.value();</span><br><span class="line">                        <span class="keyword">int</span>[] parentIds = event.parentId();</span><br><span class="line">                        <span class="keyword">int</span> parentIdsLen = parentIds == <span class="keyword">null</span> ? <span class="number">0</span> : parentIds.length;</span><br><span class="line">                        <span class="comment">//循环所有id，生成ViewInfo并添加代理反射</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">int</span> value = values[i];</span><br><span class="line">                            <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                ViewInfo info = <span class="keyword">new</span> ViewInfo();</span><br><span class="line">                                info.value = value;</span><br><span class="line">                                info.parentId = parentIdsLen &gt; i ? parentIds[i] : <span class="number">0</span>;</span><br><span class="line">                                method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                                EventListenerManager.addEventMethod(finder, info, event, handler, method);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        LogUtil.e(ex.getMessage(), ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end inject event</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ButterKnife-butterknife-8-8-1"><a href="#ButterKnife-butterknife-8-8-1" class="headerlink" title="ButterKnife(butterknife:8.8.1)"></a>ButterKnife(butterknife:8.8.1)</h3><p>ButerKnife主要会引入两个module(1个是他的核心实现，1个是他的所有的注解)</p><p>简单点就是</p><p>1.编译的时候ButterKnifeProcessor  生成 .java  –&gt; class文件</p><p>2.运行是viewBinder.bind(finder, target, source);</p><p>源码解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span> <span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(@NonNull Activity target)</span> </span>&#123;</span><br><span class="line">    View sourceView = target.getWindow().getDecorView();</span><br><span class="line">    <span class="keyword">return</span> createBinding(target, sourceView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在点到createBinding()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unbinder <span class="title">createBinding</span><span class="params">(@NonNull Object target, @NonNull View source)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">    <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Looking up binding for "</span> + targetClass.getName());</span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Unbinder.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(target, source);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to invoke "</span> + constructor, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to invoke "</span> + constructor, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">      Throwable cause = e.getCause();</span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to create binding instance."</span>, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createBinding()方法主要就是拿到我们绑定的Activity的Class，然后通过Constructor构造器获取一个Unbinder子类的构造方法，然后在调用newInstance(target, source)通过构造方法获取到Unbinder子类的一个实例，这里传入两个参数，说明构造方法里需要两个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span> <span class="meta">@CheckResult</span> <span class="meta">@UiThread</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</span><br><span class="line"> <span class="comment">//见下方</span></span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);</span><br><span class="line">    <span class="keyword">if</span> (bindingCtor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Cached in binding map."</span>);</span><br><span class="line">      <span class="keyword">return</span> bindingCtor;</span><br><span class="line">    &#125;</span><br><span class="line">    String clsName = cls.getName();</span><br><span class="line">    <span class="keyword">if</span> (clsName.startsWith(<span class="string">"android."</span>) || clsName.startsWith(<span class="string">"java."</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"MISS: Reached framework class. Abandoning search."</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//传入要绑定的类名</span></span><br><span class="line">      Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + <span class="string">"_ViewBinding"</span>);</span><br><span class="line">      <span class="comment">//noinspection unchecked</span></span><br><span class="line">      <span class="comment">//反射调用构造方法，相当于拿到Class_ViewBinding(通过ButterKnifeProcessor生成)的实例，</span></span><br><span class="line">      bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Loaded binding class and constructor."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Not found. Trying superclass "</span> + cls.getSuperclass().getName());</span><br><span class="line">      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to find binding constructor for "</span> + clsName, e);</span><br><span class="line">    &#125;</span><br><span class="line">    BINDINGS.put(cls, bindingCtor);</span><br><span class="line">    <span class="keyword">return</span> bindingCtor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//这个BINDINGS数据结构主要保存了Class作为Key，Class_ViewBinding作为Value的目的是提高缓存和bind性能，Class_ViewBinding就是生成的Unbinder的子类。</span></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>ButterKnife生成类的路径：<br>Build -&gt; intermediates -&gt; classes -&gt; debug -&gt; com…</p><p>在build.gradle文件里可以看到这个自定义注解处理器，项目中是找不到这个文件的<br>annotationProcessor ‘com.jakewharton:butterknife-compiler:8.8.1’</p><p><a href="https://github.com/JakeWharton/butterknife/tree/master/butterknife-compiler" target="_blank" rel="noopener">ButterKnife-Compiler源码地址</a></p><h2 id="手写IOC框架"><a href="#手写IOC框架" class="headerlink" title="手写IOC框架"></a>手写IOC框架</h2><p>首先声明自定义注解.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EventViewById &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EventOnClick &#123;</span><br><span class="line">    <span class="keyword">int</span>[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过反射找到自定义的注入属性并且获取自定义属性上面的值，通过反射将找到的View注入属性中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注入属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> viewFinder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@android</span>.annotation.TargetApi(<span class="number">24</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectField</span><span class="params">(ViewFinder viewFinder, Object object)</span> </span>&#123;</span><br><span class="line">    Class clazz = object.getClass();</span><br><span class="line">    Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        <span class="comment">//获取属性上面的注解值</span></span><br><span class="line">        EventViewById bindViewById = field.getAnnotation(EventViewById.class);</span><br><span class="line">        <span class="keyword">if</span> (bindViewById != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> viewId = bindViewById.value();</span><br><span class="line">            View view = viewFinder.findViewById(viewId);</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//通过反射注入属性</span></span><br><span class="line">                    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    field.set(object, view);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">                    ex.toString();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入事件以及绑定点击事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注入事件</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> viewFinder</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@android</span>.annotation.TargetApi(<span class="number">24</span>)</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectEvent</span><span class="params">(ViewFinder viewFinder, Object object)</span> </span>&#123;</span><br><span class="line">       Class clazz = object.getClass();</span><br><span class="line">       Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">       <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">           <span class="comment">//获取方法上面的注解值</span></span><br><span class="line">           EventOnClick clickEvent = method.getDeclaredAnnotation(EventOnClick.class);</span><br><span class="line">           <span class="keyword">if</span> (clickEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span>[] viewIds = clickEvent.value();</span><br><span class="line">               <span class="keyword">if</span> (viewIds.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> viewId : viewIds) &#123;</span><br><span class="line">                       View view = viewFinder.findViewById(viewId);</span><br><span class="line">                       <span class="keyword">boolean</span> isCheckNet = method.getAnnotation(EventCheckNet.class) != <span class="keyword">null</span>;</span><br><span class="line">                       <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           view.setOnClickListener(<span class="keyword">new</span> DeclaredOnClickListener(method, isCheckNet, object));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeclaredOnClickListener</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> Method mMethod;</span><br><span class="line">       <span class="keyword">private</span> Object mHandlerType;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">boolean</span> mIsNet;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DeclaredOnClickListener</span><span class="params">(Method method, <span class="keyword">boolean</span> isNet, Object object)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.mMethod = method;</span><br><span class="line">           <span class="keyword">this</span>.mHandlerType = object;</span><br><span class="line">           <span class="keyword">this</span>.mIsNet = isNet;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (mIsNet) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!isNetworkConnected(view.getContext())) &#123;</span><br><span class="line">                   Toast.makeText(view.getContext(), <span class="string">"no net"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//通过反射</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               mMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">               mMethod.invoke(mHandlerType, view);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式六原则 - 开闭原则</title>
      <link href="/home/2017/11/02/frame_design_ocp/"/>
      <url>/home/2017/11/02/frame_design_ocp/</url>
      <content type="html"><![CDATA[<p><img src="1.jpg" alt="image"></p><h2 id="开闭原则-Open-Closed-Principle-OCP"><a href="#开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="开闭原则(Open-Closed Principle, OCP)"></a>开闭原则(Open-Closed Principle, OCP)</h2><blockquote><p>用抽象构建框架，用实现扩展细节。</p></blockquote><ul><li><p>抽象化是开闭原则的关键</p></li><li><p>系统中对扩展开放，对修改关闭，模块应该在不修改原有代码的基础上进行扩展开发过程中，对系统进行抽象化设计，抽象化是开闭原则的关键，仅对程序中出现变化的地方做出抽象，拒绝不成熟的抽象和抽象本身一样重要。</p></li><li><p>修改配置文件xml或者properties而没有对源代码进行修改，认为该次修改是符合开闭原则的。</p></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>第一个版本需求只有绘制圆圈的功能，第二个版本则增加了绘制线条的功能。改进方式是在源码处进行了修改增加判断else if逻辑，这样就违反了开闭原则。</p><p><img src="oc1.jpg" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Line</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw a line....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw a circle....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Canvas</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制</span></span><br><span class="line"><span class="comment"> * 增加绘制线条，则修改CanvasDraw这个类源码，增加判断逻辑，违反开闭原则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(type.equals(<span class="string">"circle"</span>))&#123;</span><br><span class="line">       Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">       circle.draw();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( type.equals(<span class="string">"line"</span>))&#123;</span><br><span class="line">       Line line = <span class="keyword">new</span> Line();</span><br><span class="line">       line.draw();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Canvas canvas = <span class="keyword">new</span> Canvas();</span><br><span class="line">    canvas.draw(<span class="string">"circle"</span>);</span><br><span class="line">    canvas.draw(<span class="string">"line"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><img src="frame_design_ocp/oc2.jpg" alt="image"></p><p>所以还是应该用到抽象！将图形类型进行抽象化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Line</span> <span class="keyword">extends</span> <span class="title">AbstractGraph</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw a line....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">AbstractGraph</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw a circle....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Canvas</span> </span>&#123;</span><br><span class="line">    AbstractGraph abstractGraph;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        abstractGraph.draw();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAbstractGraph</span><span class="params">(AbstractGraph graph)</span></span>&#123;</span><br><span class="line">        abstractGraph = graph;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//符合开闭原则的设计</span></span><br><span class="line">        Canvas draw = <span class="keyword">new</span> Canvas();</span><br><span class="line">        draw.setAbstractGraph(<span class="keyword">new</span> Line());</span><br><span class="line">        draw.draw();</span><br><span class="line">        draw.setAbstractGraph(<span class="keyword">new</span> Circle());</span><br><span class="line">        draw.draw();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>六大设计原则：</p><ul><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_ocp/">开闭原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_srp/">单一职责原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lis/">里氏替换原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_dip/">依赖倒置原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_isp/">接口隔离原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lod/">迪米特法则</a></li></ul>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式六原则 - 迪米特法则</title>
      <link href="/home/2017/11/02/frame_design_lod/"/>
      <url>/home/2017/11/02/frame_design_lod/</url>
      <content type="html"><![CDATA[<h2 id="迪米特法则-Law-of-Demeter-LoD）"><a href="#迪米特法则-Law-of-Demeter-LoD）" class="headerlink" title="迪米特法则(Law of  Demeter, LoD）"></a>迪米特法则(Law of  Demeter, LoD）</h2><blockquote><p>一个软件实体应当尽可能少地与其他实体发生相互作用</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p></li><li><p>在类的创建上尽量创建松耦合的类，类之间耦合越低，越容易重复利用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</p></li><li><p>只与你的”直接朋友”通信</p><ul><li>当前对象本身(this)；</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象；</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</li><li>当前对象所创建的对象。 </li></ul></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getAllStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">            Student emp = <span class="keyword">new</span> Student();</span><br><span class="line">            emp.setId(<span class="string">"学生"</span>+i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Teacher&gt; <span class="title">getAllTeacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Teacher&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</span><br><span class="line">            Teacher emp = <span class="keyword">new</span> Teacher();</span><br><span class="line">            emp.setId(<span class="string">"老师"</span>+i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllStudentAndTeacher</span><span class="params">(StudentManager studentManager)</span></span>&#123;</span><br><span class="line">        List&lt;Student&gt; list1 = studentManager.getAllStudent();</span><br><span class="line">        <span class="keyword">for</span>(Student e:list1)&#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Teacher&gt; list2 = <span class="keyword">this</span>.getAllTeacher();</span><br><span class="line">        <span class="keyword">for</span>(Teacher e:list2)&#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TeacherManager e = <span class="keyword">new</span> TeacherManager();</span><br><span class="line">        e.printAllStudentAndTeacher(<span class="keyword">new</span> StudentManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据迪米特法则，只与直接的朋友发生通信，TeacherManager里面不应该有学生有联系，这样就增加了不必要的耦合。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getAllStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">            Student emp = <span class="keyword">new</span> Student();</span><br><span class="line">            emp.setId(<span class="string">"学生"</span>+i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">this</span>.getAllStudent();</span><br><span class="line">        <span class="keyword">for</span>(Student e:list)&#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老师同上</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TeacherManager e = <span class="keyword">new</span> TeacherManager();</span><br><span class="line">        e.printTeacher();</span><br><span class="line">        StudentManager s = <span class="keyword">new</span> StudentManager();</span><br><span class="line">        s.printStudent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>六大设计原则：</p><ul><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_ocp/">开闭原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_srp/">单一职责原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lis/">里氏替换原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_dip/">依赖倒置原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_isp/">接口隔离原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lod/">迪米特法则</a></li></ul>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式六原则 - 里氏替换原则</title>
      <link href="/home/2017/11/02/frame_design_lis/"/>
      <url>/home/2017/11/02/frame_design_lis/</url>
      <content type="html"><![CDATA[<h2 id="里氏替换原则-Liskov-Substitution-Principle-LSP）"><a href="#里氏替换原则-Liskov-Substitution-Principle-LSP）" class="headerlink" title="里氏替换原则(Liskov Substitution Principle, LSP）"></a>里氏替换原则(Liskov Substitution Principle, LSP）</h2><blockquote><p>所有引用基类（父类）的地方必须能透明地使用其子类的对象。(子类可以扩展父类的功能，但不能改变父类原有的功能)</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>里氏代换原则是实现开闭原则的重要方式之一</p></li><li><p>在程序中尽量使用基类类型对对象进行定义，而在运行时再确定其子类型，用子类来替换父类。</p></li><li><p>最好将父类定义为抽象类或者接口，让子类去继承或者实现。运行时，子类实例替换父类实例，如果添加新功能，就新加一个子类。</p></li><li><p>Java 编译阶段中，Java 编辑器会检查一个程序是否符合里氏替换原则，这是一个与实现无关的、语意上的检查</p></li><li><p>尽量不去重载和重写父类的方法</p></li><li><p>传递参数时使用基类对象，除此以外，在定义成员变量、定义局部变量、确定方法返回类型时都可使用里氏代换原则。针对基类编程，在程序运行时再确定具体子类。</p></li></ul><h3 id="继承带来的风险"><a href="#继承带来的风险" class="headerlink" title="继承带来的风险"></a>继承带来的风险</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a,b)+<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 因为不小心重写了父类的fun1方法，导致原本正常的相减功能异常</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(<span class="string">"100-50="</span>+b.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">        System.out.println(<span class="string">"100-80="</span>+b.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">        System.out.println(<span class="string">"100+20+100="</span>+b.func2(<span class="number">100</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义.</p><p>六大设计原则：</p><ul><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_ocp/">开闭原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_srp/">单一职责原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lis/">里氏替换原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_dip/">依赖倒置原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_isp/">接口隔离原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lod/">迪米特法则</a></li></ul>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式六原则 - 接口隔离原则</title>
      <link href="/home/2017/11/02/frame_design_isp/"/>
      <url>/home/2017/11/02/frame_design_isp/</url>
      <content type="html"><![CDATA[<h2 id="接口隔离原则-InterfaceSegregationPrinciple-ISP"><a href="#接口隔离原则-InterfaceSegregationPrinciple-ISP" class="headerlink" title="接口隔离原则(InterfaceSegregationPrinciple,ISP)"></a>接口隔离原则(InterfaceSegregationPrinciple,ISP)</h2><blockquote><p>每一个接口承担独立的，较小，适当密度的功能，做好自己仅有的功能.</p></blockquote><ul><li><p>接口就是一个类型所提供的所有方法特征集合的概率，接口的划分就是类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色是一个特定的接口，这就叫“接口隔离原则”</p></li><li><p>接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</p></li><li><p>单一职责原则原注重的是职责，而接口隔离原则注重对接口依赖的隔离。单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节，而接口隔离原则主要约束接口接口，主要针对抽象。</p></li><li><p>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</p></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDisplay</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dataRead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transformTOXML</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createChart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayChart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际实现接口中，可能难免避免有些是空方法，比如，本来就是一个XML文件，就没必要在去实现第二个方法。</p><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dataRead</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XMLHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transformTOXML</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChartHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createChart</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayChart</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实很好理解：在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</p><p>六大设计原则：</p><ul><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_ocp/">开闭原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_srp/">单一职责原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lis/">里氏替换原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_dip/">依赖倒置原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_isp/">接口隔离原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lod/">迪米特法则</a></li></ul>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式六原则 - 依赖倒置原则</title>
      <link href="/home/2017/11/02/frame_design_dip/"/>
      <url>/home/2017/11/02/frame_design_dip/</url>
      <content type="html"><![CDATA[<h2 id="依赖倒置原则-DependencyInversionPrinciple-DIP）"><a href="#依赖倒置原则-DependencyInversionPrinciple-DIP）" class="headerlink" title="依赖倒置原则(DependencyInversionPrinciple, DIP）"></a>依赖倒置原则(DependencyInversionPrinciple, DIP）</h2><blockquote><p>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p></blockquote><ul><li><p>依赖倒置原则的核心思想是面向接口编程</p></li><li><p>相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。</p></li><li><p>如果说开闭原则是面向对象的设计目标，依赖倒置就是实现的主要机制之一</p></li><li><p>将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p></li><li><p>低层模块尽量都要有抽象类或接口，或者两者都有。</p></li><li><p>变量的声明类型尽量是抽象类或接口。</p></li><li><p>使用继承时遵循里氏替换原则。</p></li></ul><p>说的那么复杂给个例子来说明下</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"获取书的内容"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Book book)</span></span>&#123;</span><br><span class="line">System.out.println(book.getContent());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();  </span><br><span class="line">        p.read(<span class="keyword">new</span> Book());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还要读取报纸或者其他类型，就要不断修改Person类，这样的设计肯定不好。所以就引入一个抽象化的接口IReader来降低Person和Book之间的耦合。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IReader</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getContent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">IReader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"读取书中的内容"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsPaper</span> <span class="keyword">implements</span> <span class="title">IReader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"读取报纸内容"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(IReader reader)</span></span>&#123;</span><br><span class="line">        System.out.println(reader.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.read(<span class="keyword">new</span> Book());</span><br><span class="line">        person.read(<span class="keyword">new</span> NewsPaper());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>六大设计原则：</p><ul><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_ocp/">开闭原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_srp/">单一职责原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lis/">里氏替换原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_dip/">依赖倒置原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_isp/">接口隔离原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lod/">迪米特法则</a></li></ul>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式六原则 - 单一职责原则</title>
      <link href="/home/2017/11/02/frame_design_srp/"/>
      <url>/home/2017/11/02/frame_design_srp/</url>
      <content type="html"><![CDATA[<h2 id="单一职责-Single-Responsibility-Principle-SRP"><a href="#单一职责-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责(Single Responsibility Principle, SRP)"></a>单一职责(Single Responsibility Principle, SRP)</h2><blockquote><p>一个类只负责一项职责，一个功能只负责一项职责。</p></blockquote><ul><li>随着项目不停的迭代，复杂度的提升，一个类的功能越来越多，耦合度越来越高，一旦修改功能，可能导致其他功能正常运行，违背了单一职责原则。一个类只负责一项职责，每个类都是由一组相关性很高的函数变量组成，核心思想就是实现高内聚、低耦合。</li><li><p>不要盲目的追求类的单一原则而导致代码类目变大，应该同时有平衡的追求类的单一原则和方法的单一原则。</p></li><li><p>优点：</p><ul><li>降低类和方法的复杂度，一个类和一个方法只有一项职责，逻辑清楚明了；</li><li>可维护性和可读性更高；</li><li>变更引起的风险很低。改一处功能，其他地方影响很小；</li></ul></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃树叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.eat(<span class="string">"马"</span>);</span><br><span class="line">        animal.eat(<span class="string">"牛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在版本进行迭代，不只是需要吃树叶还需要吃肉。</p><h2 id="解决1-类的单一职责"><a href="#解决1-类的单一职责" class="headerlink" title="解决1(类的单一职责)"></a>解决1(类的单一职责)</h2><p>将动物划分更细为食肉动物和食草动物。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Carnivores</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃肉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrassAnimal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃树叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Carnivores carnivores = <span class="keyword">new</span> Carnivores();</span><br><span class="line">        carnivores.eat(<span class="string">"马"</span>);</span><br><span class="line">        GrassAnimal grassAnimal = <span class="keyword">new</span> GrassAnimal();</span><br><span class="line">        grassAnimal.eat(<span class="string">"牛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决2-方法的单一职责"><a href="#解决2-方法的单一职责" class="headerlink" title="解决2(方法的单一职责)"></a>解决2(方法的单一职责)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃树叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat2</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃肉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.eat(<span class="string">"马"</span>);</span><br><span class="line">        animal.eat2(<span class="string">"牛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文的栗子很简单，只有一个方法，所以是方法1还是方法2都影响不大。实际情况中的类都要复杂很多，一旦发生职责扩散而需要修改类时，除非这个类非常简单，否则还是遵循单一职责原则。</p><p>六大设计原则：</p><ul><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_ocp/">开闭原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_srp/">单一职责原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lis/">里氏替换原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_dip/">依赖倒置原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_isp/">接口隔离原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lod/">迪米特法则</a></li></ul>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式六原则 - 单一职责原则</title>
      <link href="/home/2017/11/02/c4jni_4/"/>
      <url>/home/2017/11/02/c4jni_4/</url>
      <content type="html"><![CDATA[<h2 id="单一职责-Single-Responsibility-Principle-SRP"><a href="#单一职责-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责(Single Responsibility Principle, SRP)"></a>单一职责(Single Responsibility Principle, SRP)</h2><blockquote><p>一个类只负责一项职责，一个功能只负责一项职责。</p></blockquote><ul><li>随着项目不停的迭代，复杂度的提升，一个类的功能越来越多，耦合度越来越高，一旦修改功能，可能导致其他功能正常运行，违背了单一职责原则。一个类只负责一项职责，每个类都是由一组相关性很高的函数变量组成，核心思想就是实现高内聚、低耦合。</li><li><p>不要盲目的追求类的单一原则而导致代码类目变大，应该同时有平衡的追求类的单一原则和方法的单一原则。</p></li><li><p>优点：</p><ul><li>降低类和方法的复杂度，一个类和一个方法只有一项职责，逻辑清楚明了；</li><li>可维护性和可读性更高；</li><li>变更引起的风险很低。改一处功能，其他地方影响很小；</li></ul></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃树叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.eat(<span class="string">"马"</span>);</span><br><span class="line">        animal.eat(<span class="string">"牛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在版本进行迭代，不只是需要吃树叶还需要吃肉。</p><h2 id="解决1-类的单一职责"><a href="#解决1-类的单一职责" class="headerlink" title="解决1(类的单一职责)"></a>解决1(类的单一职责)</h2><p>将动物划分更细为食肉动物和食草动物。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Carnivores</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃肉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrassAnimal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃树叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Carnivores carnivores = <span class="keyword">new</span> Carnivores();</span><br><span class="line">        carnivores.eat(<span class="string">"马"</span>);</span><br><span class="line">        GrassAnimal grassAnimal = <span class="keyword">new</span> GrassAnimal();</span><br><span class="line">        grassAnimal.eat(<span class="string">"牛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决2-方法的单一职责"><a href="#解决2-方法的单一职责" class="headerlink" title="解决2(方法的单一职责)"></a>解决2(方法的单一职责)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃树叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat2</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃肉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.eat(<span class="string">"马"</span>);</span><br><span class="line">        animal.eat2(<span class="string">"牛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文的栗子很简单，只有一个方法，所以是方法1还是方法2都影响不大。实际情况中的类都要复杂很多，一旦发生职责扩散而需要修改类时，除非这个类非常简单，否则还是遵循单一职责原则。</p><p>六大设计原则：</p><ul><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_ocp/">开闭原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_srp/">单一职责原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lis/">里氏替换原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_dip/">依赖倒置原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_isp/">接口隔离原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lod/">迪米特法则</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式六原则 - 单一职责原则</title>
      <link href="/home/2017/11/02/c4jni_3/"/>
      <url>/home/2017/11/02/c4jni_3/</url>
      <content type="html"><![CDATA[<h2 id="单一职责-Single-Responsibility-Principle-SRP"><a href="#单一职责-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责(Single Responsibility Principle, SRP)"></a>单一职责(Single Responsibility Principle, SRP)</h2><blockquote><p>一个类只负责一项职责，一个功能只负责一项职责。</p></blockquote><ul><li>随着项目不停的迭代，复杂度的提升，一个类的功能越来越多，耦合度越来越高，一旦修改功能，可能导致其他功能正常运行，违背了单一职责原则。一个类只负责一项职责，每个类都是由一组相关性很高的函数变量组成，核心思想就是实现高内聚、低耦合。</li><li><p>不要盲目的追求类的单一原则而导致代码类目变大，应该同时有平衡的追求类的单一原则和方法的单一原则。</p></li><li><p>优点：</p><ul><li>降低类和方法的复杂度，一个类和一个方法只有一项职责，逻辑清楚明了；</li><li>可维护性和可读性更高；</li><li>变更引起的风险很低。改一处功能，其他地方影响很小；</li></ul></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃树叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.eat(<span class="string">"马"</span>);</span><br><span class="line">        animal.eat(<span class="string">"牛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在版本进行迭代，不只是需要吃树叶还需要吃肉。</p><h2 id="解决1-类的单一职责"><a href="#解决1-类的单一职责" class="headerlink" title="解决1(类的单一职责)"></a>解决1(类的单一职责)</h2><p>将动物划分更细为食肉动物和食草动物。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Carnivores</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃肉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrassAnimal</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃树叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Carnivores carnivores = <span class="keyword">new</span> Carnivores();</span><br><span class="line">        carnivores.eat(<span class="string">"马"</span>);</span><br><span class="line">        GrassAnimal grassAnimal = <span class="keyword">new</span> GrassAnimal();</span><br><span class="line">        grassAnimal.eat(<span class="string">"牛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决2-方法的单一职责"><a href="#解决2-方法的单一职责" class="headerlink" title="解决2(方法的单一职责)"></a>解决2(方法的单一职责)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃树叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat2</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal + <span class="string">"吃肉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.eat(<span class="string">"马"</span>);</span><br><span class="line">        animal.eat2(<span class="string">"牛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文的栗子很简单，只有一个方法，所以是方法1还是方法2都影响不大。实际情况中的类都要复杂很多，一旦发生职责扩散而需要修改类时，除非这个类非常简单，否则还是遵循单一职责原则。</p><p>六大设计原则：</p><ul><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_ocp/">开闭原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_srp/">单一职责原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lis/">里氏替换原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_dip/">依赖倒置原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_isp/">接口隔离原则</a></li><li><a href="https://kevinrocka.github.io/home/2017/11/02/frame_design_lod/">迪米特法则</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JNI - C基础2</title>
      <link href="/home/2017/11/02/c4jni_2/"/>
      <url>/home/2017/11/02/c4jni_2/</url>
      <content type="html"><![CDATA[<h2 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h2><h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><h2 id="指针赋值"><a href="#指针赋值" class="headerlink" title="指针赋值"></a>指针赋值</h2><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2>]]></content>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JNI - C基础1</title>
      <link href="/home/2017/11/02/c4jni_1/"/>
      <url>/home/2017/11/02/c4jni_1/</url>
      <content type="html"><![CDATA[<blockquote><p>JNI 基础回顾(占位符，sizeof，for循环，指针)</p></blockquote><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(<span class="string">"%s\n"</span>,<span class="string">"Hello Rocka"</span>);</span><br></pre></td></tr></table></figure><p>占位符以及占位符意义：</p><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:right">占位符</th></tr></thead><tbody><tr><td style="text-align:left">%d</td><td style="text-align:right">十进制整数占位符</td></tr><tr><td style="text-align:left">%c</td><td style="text-align:right">字符占位符</td></tr><tr><td style="text-align:left">%i</td><td style="text-align:right">十进制、八进制、十六进制整数占位符</td></tr><tr><td style="text-align:left">%p</td><td style="text-align:right">地址占位符（指针占位符）</td></tr><tr><td style="text-align:left">%f(.2f)</td><td style="text-align:right">浮点类型占位符(小数点后.2f)</td></tr><tr><td style="text-align:left">%x(X)</td><td style="text-align:right">十六进制整数占位符</td></tr><tr><td style="text-align:left">%s</td><td style="text-align:right">字符串占位符</td></tr><tr><td style="text-align:left">%o</td><td style="text-align:right">八进制整数占位符</td></tr></tbody></table><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(<span class="string">"int类型所占%d字节数\n"</span> , sizeof(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>Windows得写法如果不标准不一定能在Linux下使用，例如下面两个:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法1：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line">printf(<span class="string">"%d\n"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法2:</span></span><br><span class="line"><span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">printf(<span class="string">"%d\n"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>主要用scanf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">printf(<span class="string">"请输入一个整数:"</span>);</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">printf(<span class="string">"i的值为:%d\n"</span>,a);</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote><p>指针存储的是变量的内存地址),内存地址(系统给数据分配的门牌号)</p></blockquote><p>定义：<br>在计算机中，所有的数据都是存放在内存中的，一般把内存中的一个字节称为一个内存单元，不同的数据类型所占用的内存单元数不一样，如int占用4个字节，char占用1个字节。为了正确地访问这些内存单元，必须为每个内存单元编上号。每个内存单元的编号是唯一的，根据编号可以准确地找到该内存单元。</p><p>内存单元的编号叫做地址（Address），也称为指针（Pointer）。 </p><p>指针示例1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;b;<span class="comment">//创建一个int类型的指针，并且给他赋值，p的值就是b这个变量的内存地址</span></span><br><span class="line">printf(<span class="string">"%#x\n"</span>,p);</span><br><span class="line"></span><br><span class="line">--&gt;<span class="number">0xefa7780c</span></span><br></pre></td></tr></table></figure><p>指针示例2:</p><p>间接赋值。变量名，对内存空间上的一段数据的抽象.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> *point = &amp;c;</span><br><span class="line">printf(<span class="string">"修改前%d\n"</span> , c);</span><br><span class="line">*point = <span class="number">200</span>;</span><br><span class="line">printf(<span class="string">"修改后%d\n"</span> , c);</span><br><span class="line">change(&amp;c);</span><br><span class="line">printf(<span class="string">"再次修改后%d\n"</span> , c);</span><br><span class="line"></span><br><span class="line">--&gt;修改前<span class="number">40</span></span><br><span class="line">--&gt;修改后<span class="number">200</span></span><br><span class="line">--&gt;再次修改后<span class="number">150</span></span><br></pre></td></tr></table></figure><h2 id="指针其他"><a href="#指针其他" class="headerlink" title="指针其他"></a>指针其他</h2><ol><li><p>外挂：通过动态链接库注入的方式来修改内存地址来修改内存地址对应的变量，像以前的金山游侠修改器一样。</p></li><li><p>指针有类型，地址没有类型，地址只是内存开始的位置，类型是读取到什么位置结束。比如int读取四个字节，double读取八个字节</p></li><li><p>空指针的默认值为0</p></li></ol>]]></content>
      
      <categories>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
            <tag> JNI </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VR App开发 小记</title>
      <link href="/home/2017/11/02/Unity3D/"/>
      <url>/home/2017/11/02/Unity3D/</url>
      <content type="html"><![CDATA[<blockquote><p>最近一个APP需要接入Cardboard，Daydream和Oculus三种SDK，这里简单介绍接入流程以及SDK运行先后顺序。 </p></blockquote><h3 id="Daydream-amp-amp-Cardboard-amp-amp-Oculus"><a href="#Daydream-amp-amp-Cardboard-amp-amp-Oculus" class="headerlink" title="Daydream &amp;&amp; Cardboard &amp;&amp; Oculus"></a>Daydream &amp;&amp; Cardboard &amp;&amp; Oculus</h3><blockquote><p>Daydream 和 Cardboard都是Google VR开发的SDK ，谷歌VR的APP都是用Daydream进行开发的。</p></blockquote><h2 id="编译的顺序以及性能问题"><a href="#编译的顺序以及性能问题" class="headerlink" title="编译的顺序以及性能问题"></a>编译的顺序以及性能问题</h2><ul><li><p>如果在VR SDK 列表中Cardboard在Daydream前面，即使是Daydream硬件设备也不会运行Daydream模式</p></li><li><p>如果在VR SDK 列表中只有Daydream，VR Android Manifest上也加上了条目，App会出现在VR 谷歌市场中，所以所有支持Daydream的设备也会支持异步多重投影技术</p></li><li><p>如果在VR SDK 列表中只有Cardboard，App不会出现在VR 谷歌市场中，即使在支持的设备上也不会有异步多重投影技术和持续的高性能表现</p></li><li><p>如果在VR SDK 列表中都勾选Daydream和Cardboard，在支持的设备上会有异步多重投影技术，如果勾选持续高性能表现也会在支持的设备上出现，同时App会出现在VR 谷歌市场    </p></li><li><p>如果要三个Daydream &amp;&amp; Cardboard &amp;&amp; Oculus都支持，将Oculus放在最上面。支持Gear VR的设备会先编译Gear VR，不支持的就会去回退选择Daydream和Cardboard。</p></li><li><p>发布到Gear VR首先确保你能发布一个Unity app 在你的Galaxy Note 5, S6 Edge+, S6, or S6 Edge，然后把Oculus加入编译List，最后在你的项目Assets文件夹下创建文件夹Plugins/Android/assets(大小写相关)，并且要包含Oculus的签名文件。</p></li></ul><h2 id="Oculus"><a href="#Oculus" class="headerlink" title="Oculus"></a>Oculus</h2><ul><li><p>Unity 5.1 或者以上的版本自带Oculus支持，在Other Settings &gt; Configuration &gt; Player Settings, 中可以看到.</p></li><li><p>Oculus下的签名文件Oculussigxxxxxxxx必须正确放置Plugins/Android/assets,不然会出现Thread Priority Security Exception，Make sure the APK is signed.<br>同时一个设备生成的签名只能用于这个设备，这也就导致出了另外一个问题，如果想发布线上，只有更改架构。oculus设备把自己的设备id发给服务端，服务端根据设备id生成oculus.sig签名文件，用签名文件和场景打包，当前设备的apk场景。</p></li></ul><h2 id="开发遇到的问题"><a href="#开发遇到的问题" class="headerlink" title="开发遇到的问题"></a>开发遇到的问题</h2><ul><li><p>U3D切换场景</p><p>  不要忘记还需要在File-&gt;Building Setting中设置添加场景，否则也不能实现切换成功,Application.LoadLevel(“HuHuVRVideo”)，已经过时。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SceneManager.LoadScene(<span class="string">"HuHuVRVideo"</span>);</span><br></pre></td></tr></table></figure></li><li><p>正确删除某个组件下所有子item</p><p>  不是用for循环去遍历</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(m_GridLayout.transform.childCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">DestroyImmediate(m_GridLayout.transform.GetChild(<span class="number">0</span>).gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当凝视交互和UI层，交互的圈，可能被遮住看不到，调整Canva是的属性，Sorting Layer 改为GUI层，所有的交互都可以看到了。</p></li></ul>]]></content>
      
      <categories>
          
          <category> Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VR </tag>
            
            <tag> Unity3D </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>热更新 AndFix 源码解析</title>
      <link href="/home/2017/11/02/android_rocka_hotfix/"/>
      <url>/home/2017/11/02/android_rocka_hotfix/</url>
      <content type="html"><![CDATA[<blockquote><p>阿里老框架热更新：<a href="https://github.com/alibaba/AndFix" target="_blank" rel="noopener">https://github.com/alibaba/AndFix</a></p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>0.命令行生成拆分包 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apkpatch.bat -f 修复的apk -t 老的apk -o 输出 -k 签名文件 -p 签名密码 -a 签名别名 -e 签名别名密码</span><br></pre></td></tr></table></figure><p>1.PatchManager.init()初始化</p><p>2.PatchManager.addPatch(path);</p><p>3.PatchManager.loadPatch();</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>1.初始化，检测当前app的patch目录是否存在，并且检测当前版本是否与本地相匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String appVersion)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!mPatchDir.exists() &amp;&amp; !mPatchDir.mkdirs()) &#123;<span class="comment">// make directory fail</span></span><br><span class="line">Log.e(TAG, <span class="string">"patch dir create error."</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mPatchDir.isDirectory()) &#123;<span class="comment">// not directory</span></span><br><span class="line">mPatchDir.delete();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">SharedPreferences sp = mContext.getSharedPreferences(SP_NAME,</span><br><span class="line">Context.MODE_PRIVATE);</span><br><span class="line">String ver = sp.getString(SP_VERSION, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (ver == <span class="keyword">null</span> || !ver.equalsIgnoreCase(appVersion)) &#123;</span><br><span class="line">cleanPatch();</span><br><span class="line">sp.edit().putString(SP_VERSION, appVersion).commit();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">initPatchs();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将应用目录下apatch目录下的后缀名为.apatch的文件添加到线程安全的数据结构中保存</span></span><br><span class="line">SortedSet&lt;Patch&gt; mPatchs = <span class="keyword">new</span> ConcurrentSkipListSet&lt;Patch&gt;();</span><br><span class="line"><span class="function"><span class="keyword">private</span> Patch <span class="title">addPatch</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">Patch patch = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (file.getName().endsWith(SUFFIX)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">patch = <span class="keyword">new</span> Patch(file);</span><br><span class="line">mPatchs.add(patch);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">Log.e(TAG, <span class="string">"addPatch"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> patch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.加载</p>]]></content>
      
      <categories>
          
          <category> Android进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>运行时权限</title>
      <link href="/home/2017/10/31/android_permission/"/>
      <url>/home/2017/10/31/android_permission/</url>
      <content type="html"><![CDATA[<blockquote><p>Android 6.0以上运行时权限，回顾，总结！</p></blockquote><h2 id="权限分组"><a href="#权限分组" class="headerlink" title="权限分组"></a>权限分组</h2><ul><li><p>普通权限</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ACCESS_LOCATION_EXTRA_COMMANDS</span><br><span class="line">ACCESS_NETWORK_STATE</span><br><span class="line">ACCESS_NOTIFICATION_POLICY</span><br><span class="line">ACCESS_WIFI_STATE</span><br><span class="line">BLUETOOTH</span><br><span class="line">BLUETOOTH_ADMIN</span><br><span class="line">BROADCAST_STICKY</span><br><span class="line">CHANGE_NETWORK_STATE</span><br><span class="line">CHANGE_WIFI_MULTICAST_STATE</span><br><span class="line">CHANGE_WIFI_STATE</span><br><span class="line">DISABLE_KEYGUARD</span><br><span class="line">EXPAND_STATUS_BAR</span><br><span class="line">GET_PACKAGE_SIZE</span><br><span class="line">INSTALL_SHORTCUT</span><br><span class="line">INTERNET</span><br><span class="line">KILL_BACKGROUND_PROCESSES</span><br><span class="line">MODIFY_AUDIO_SETTINGS</span><br><span class="line">NFC</span><br><span class="line">READ_SYNC_SETTINGS</span><br><span class="line">READ_SYNC_STATS</span><br><span class="line">RECEIVE_BOOT_COMPLETED</span><br><span class="line">REORDER_TASKS</span><br><span class="line">REQUEST_INSTALL_PACKAGES</span><br><span class="line">SET_ALARM</span><br><span class="line">SET_TIME_ZONE</span><br><span class="line">SET_WALLPAPER</span><br><span class="line">SET_WALLPAPER_HINTS</span><br><span class="line">TRANSMIT_IR</span><br><span class="line">UNINSTALL_SHORTCUT</span><br><span class="line">USE_FINGERPRINT</span><br><span class="line">VIBRATE</span><br><span class="line">WAKE_LOCK</span><br><span class="line">WRITE_SYNC_SETTINGS</span><br></pre></td></tr></table></figure></li><li><p>危险权限</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">group:android.permission-group.CONTACTS</span><br><span class="line">  permission:android.permission.WRITE_CONTACTS</span><br><span class="line">  permission:android.permission.GET_ACCOUNTS</span><br><span class="line">  permission:android.permission.READ_CONTACTS</span><br><span class="line"></span><br><span class="line">group:android.permission-group.PHONE</span><br><span class="line">  permission:android.permission.READ_CALL_LOG</span><br><span class="line">  permission:android.permission.READ_PHONE_STATE</span><br><span class="line">  permission:android.permission.CALL_PHONE</span><br><span class="line">  permission:android.permission.WRITE_CALL_LOG</span><br><span class="line">  permission:android.permission.USE_SIP</span><br><span class="line">  permission:android.permission.PROCESS_OUTGOING_CALLS</span><br><span class="line">  permission:com.android.voicemail.permission.ADD_VOICEMAIL</span><br><span class="line"></span><br><span class="line">group:android.permission-group.CALENDAR</span><br><span class="line">  permission:android.permission.READ_CALENDAR</span><br><span class="line">  permission:android.permission.WRITE_CALENDAR</span><br><span class="line"></span><br><span class="line">group:android.permission-group.CAMERA</span><br><span class="line">  permission:android.permission.CAMERA</span><br><span class="line"></span><br><span class="line">group:android.permission-group.SENSORS</span><br><span class="line">  permission:android.permission.BODY_SENSORS</span><br><span class="line"></span><br><span class="line">group:android.permission-group.LOCATION</span><br><span class="line">  permission:android.permission.ACCESS_FINE_LOCATION</span><br><span class="line">  permission:android.permission.ACCESS_COARSE_LOCATION</span><br><span class="line"></span><br><span class="line">group:android.permission-group.STORAGE</span><br><span class="line">  permission:android.permission.READ_EXTERNAL_STORAGE</span><br><span class="line">  permission:android.permission.WRITE_EXTERNAL_STORAGE</span><br><span class="line"></span><br><span class="line">group:android.permission-group.MICROPHONE</span><br><span class="line">  permission:android.permission.RECORD_AUDIO</span><br><span class="line"></span><br><span class="line">group:android.permission-group.SMS</span><br><span class="line">  permission:android.permission.READ_SMS</span><br><span class="line">  permission:android.permission.RECEIVE_WAP_PUSH</span><br><span class="line">  permission:android.permission.RECEIVE_MMS</span><br><span class="line">  permission:android.permission.RECEIVE_SMS</span><br><span class="line">  permission:android.permission.SEND_SMS</span><br><span class="line">  permission:android.permission.READ_CELL_BROADCASTS</span><br></pre></td></tr></table></figure></li></ul><p>危险权限都是一组，如果申请某一个危险权限，默认整组危险权限都授权，权限对话框上的说明也是针对权限组。</p><h2 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h2><ul><li>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//伪代码</span><br><span class="line">if(ContextCompat.checkSelfPermission(this,</span><br><span class="line">               Manifest.permission.CALL_PHONE)!= PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">ActivityCompat.requestPermissions(this,</span><br><span class="line">                    new String[]&#123;Manifest.permission.CALL_PHONE&#125;,</span><br><span class="line">                    MY_PERMISSIONS_REQUEST_CALL_PHONE);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">callPhone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">   public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults)&#123;</span><br><span class="line">       if (requestCode == MY_PERMISSIONS_REQUEST_CALL_PHONE)&#123;</span><br><span class="line">           if (grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">               callPhone();</span><br><span class="line">           &#125; else&#123;</span><br><span class="line">               Toast.makeText(MainActivity.this, &quot;Permission Denied&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">           &#125;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       super.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="权限封装"><a href="#权限封装" class="headerlink" title="权限封装"></a>权限封装</h2><blockquote><p>GitHub 上基本上都是用的(反射 + 注解)进行封装</p></blockquote>]]></content>
      
      <categories>
          
          <category> Android进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android进阶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 性能优化 -- 内存</title>
      <link href="/home/2017/09/04/memory/"/>
      <url>/home/2017/09/04/memory/</url>
      <content type="html"><![CDATA[<blockquote><p> APP 进程一般只分配 16M,32M,64M 的内存空间，C和C++会自己分配内存(malloc)和释放内存(free)，而Java不是，So….</p></blockquote><h2 id="内存分配策略："><a href="#内存分配策略：" class="headerlink" title="内存分配策略："></a>内存分配策略：</h2><ul><li><p>静态存储区：内存空间在程序编译(类加载)的时候就分配好，这块内存在程序整个运行都一直存在。主要存放静态数据，全局static数据和一些常量。</p></li><li><p>栈式存储区：在执行方法时，方法内部变量存储放在栈上创建，方法执行结束后背释放。栈内存分配速度快，容量有限(由操作系统决定)，数据先进后出，进出不产生内存碎片，运行效率高且稳定。</p></li><li><p>堆式存储区：动态内存分配，有时候可以用malloc或者new()来申请分配一个内存。类里的对象引用也是在堆内存中。(堆是一个不连续的存错区域)</p></li></ul><h2 id="JAVA-内存回收机制-GC"><a href="#JAVA-内存回收机制-GC" class="headerlink" title="JAVA 内存回收机制(GC)"></a>JAVA 内存回收机制(GC)</h2><ul><li>基本原理：JAVA 虚拟机通过算法必须追踪运行程序中有用的对象，而且最终释放没用的对象，垃圾回收期从根开始可达对象都是活动对象，包括间接可达。不可达就是垃圾回收的对象。<ul><li>标记-清除法：标记需要清除的对象，然后清除。效率不高，产生不连续内存碎片。 </li><li>复制算法：将内存区域分为两块，每次使用一块，当这一块用完了，将存活的复制到另外一面墙，清理完一面墙。代价内存缩小一半，没有内存碎片，效率低。</li><li>标记-压缩算法：标记过程与“标记-清除”一样，但后续不是直接清除，而是所有对象移动到一端，然后清理掉边界以外的内存。</li><li>分代收集法：分为新生代(生成的对象首先都是放在年轻代的)，老年代(生命周期长的对象，年轻代经历N次回收还存活的对象)，持久代(存放静态文件，java类，方法等)。新生代有大批对象死亡，采用复制算法。老年代存活率高，就必须采用标记-清理或标记-压缩来回收。</li></ul></li></ul><h2 id="内存泄露与内存溢出"><a href="#内存泄露与内存溢出" class="headerlink" title="内存泄露与内存溢出"></a>内存泄露与内存溢出</h2><ul><li><p>内存泄露：指程序已经终止，但是一些临时对象，对象不会被GC所回收，它始终占用内存。即被分配的对象可达但已无用。</p></li><li><p>内存溢出：指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。或者说，当应用占用的堆内存资源超过了Dalvik虚拟机分配的内存就会内存溢出.</p></li></ul><h2 id="堆内存-amp-栈内存"><a href="#堆内存-amp-栈内存" class="headerlink" title="堆内存&amp;栈内存"></a>堆内存&amp;栈内存</h2><blockquote><p>Java 中数据存储的位置其实还包括寄存器(无法人为控制，自动分配)，常量池(字符串常量和基本类型常量)，非RAM存储区(流对象和持久化对象)。堆内存和栈内存都是RAM(内存)上存储。</p></blockquote><ul><li>栈内存速度大于堆内存</li><li>堆内存灵活性大于栈内存</li><li>栈可以实现数据共享。 (int a = 100 ,int b =100)</li><li>new 出来的都是堆内存，其余都是栈内存(不是很严谨)BirthDate d1= new BirthDate(1,1,1); d1对象为引用在栈中，new BirthDate()在堆中。</li></ul><h2 id="Java-常见的引用"><a href="#Java-常见的引用" class="headerlink" title="Java 常见的引用"></a>Java 常见的引用</h2><blockquote><p>　　在Java中，虽然不需要程序员手动去管理对象的生命周期，但是如果希望某些占用内存大对象具备一定的生命周期的话，可以使用SoftReference和WeakReference就能很好防止内存溢出</p></blockquote><table><thead><tr><th>引用名称</th><th>回收时机</th><th>生命周期</th><th>使用</th></tr></thead><tbody><tr><td>StrongReference(强)</td><td>从不回收</td><td>JVM停止的时候终止</td><td>用于对象的保存</td></tr><tr><td>SoftReference(软)</td><td>内存不足时</td><td>内存不足时终止</td><td>结合ReferenceQueue构造有效期短</td></tr><tr><td>WeakReference(弱)</td><td>垃圾回收时</td><td>GC后终止</td><td>同软引用</td></tr><tr><td>PhatomReference(虚)</td><td>垃圾回收时</td><td>GC后终止</td><td>结合ReferenceQueue跟踪对象被回收活动</td></tr></tbody></table><ul><li>LRU 算法和SoftReference区别：SoftReference回收量比较大，而且不能控制回收哪个对象，LRU 算法是回收最近不常使用的对象.</li></ul><h2 id="Android-找内存泄露的一般步骤"><a href="#Android-找内存泄露的一般步骤" class="headerlink" title="Android 找内存泄露的一般步骤"></a>Android 找内存泄露的一般步骤</h2><ul><li><p>确定是否存在内存泄露</p><ul><li>Android monitor 某个操作前，GC完后与动作发生后的内存大小是否一致；</li><li>MAT 中Total Size值都会稳定在一个有限的范围内，随着操作次数的增大，Total Size变大，证明操作导致内存泄露</li></ul></li><li><p>找出怀疑对象</p><ul><li>MAT对比操作前后的hprof来定位内存泄露是泄露了什么数据对象</li></ul></li><li><p>MAT分析hprof定位内存泄露</p><ul><li>一般性步骤Histogram -&gt; List Objects -&gt; with incoming references -&gt; Merge Shortest Paths to GC Roots -&gt; exclude all phantom/weak/soft etc.references</li></ul></li></ul><h2 id="Android-中常见到内存泄露案例"><a href="#Android-中常见到内存泄露案例" class="headerlink" title="Android 中常见到内存泄露案例"></a>Android 中常见到内存泄露案例</h2><ul><li><p>单例模式Context的使用不正常</p><blockquote><p>如果传入的是Activity的Context，当Activity退出时候，因为单例对象持有该Activity的引用，所以Activity退出时内存并不会回收.</p></blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context.getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非静态内部类直接在类中创建实例</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> TestResource mResource = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mManager == <span class="keyword">null</span>)&#123;</span><br><span class="line">            mManager = <span class="keyword">new</span> TestResource();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这样非静态内部类会默认持有外部类的引用，该实例生命周期和应用一样长，导致了该实例会一直持有Activity的引用，导致Activity内存资源不能回收泄露。</p></li><li><p>匿名内部类线程造成的泄露</p><p>  匿名内部类异步任务AsyncTask和Thread，在Activity销毁之前，任务还未完成，将导致Activity内存资源无法回收，内存泄露，正确做法是使用静态内部类。</p></li><li><p>资源未及时关闭回收</p><p>  在用到如下功能时候BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap，自定义属性attribute。记得Activity销毁时或者不适用的时候回收资源或者注销。</p></li><li><p>监听未移除</p><p>  最常见的就是addOnWindowFocusChangeListener，一定要在onWindowFocusChanged()回调中移除掉。</p></li><li><p>无限轮播的动画</p><p>  没有在onDestory()中停止动画，导致Activity变成泄露的对象</p></li></ul><h2 id="常见内存优化工具"><a href="#常见内存优化工具" class="headerlink" title="常见内存优化工具"></a>常见内存优化工具</h2><p>  Heap Viewer工具 , Heap Snapshot工具 , MAT , TraceView , Allocation Tracker工具。</p>]]></content>
      
      <categories>
          
          <category> Android性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Interview - 2</title>
      <link href="/home/2017/09/04/Android%20Interview%20-%20android/"/>
      <url>/home/2017/09/04/Android%20Interview%20-%20android/</url>
      <content type="html"><![CDATA[<blockquote><p>思维导图，用于面试前复习Android的基础知识点，用自己的话总结出面试要回答到的重点，可能包括一些不包括该知识点的全面概括与解析，其中也包括了面试中被问到的知识。</p></blockquote><p><img src="android.png" alt="image"></p><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><ul><li><p>Activity的四种启动模式</p><ul><li>standard 标准，默认，先进后出</li><li>singleTop （栈顶复用模式)当再次启动的界面位于栈顶，复用该实例，当再次启动的界面不位于栈顶，重新创建实例</li><li>singleTask (栈内复用模式)具有clearTop的功能</li><li>singleInstance (栈内唯一实例),系统没有该实例，新建一个任务栈，并将放入栈顶；系统有实例，使用该实例并转到前台</li></ul></li><li><p>Activity的启动流程</p><ul><li>Activity的管理核心是AMS(ActivityManagerService)，是一个独立的进程，ActivtyThread是每一个应用程序所在进程的主线程，循环的处理消息。他们之间通过binder来进行进程间的通信。</li><li>流程<ol><li>AMS发现这个activity还没启动，就会通知zygot孵化出应用进程</li><li>然后在dalvik应用进程里执行ActivityThread的main方法</li><li>应用进程会通知AMS已经启动，AMS保存了一个应用进程的代理对象，这样AMS可以通过代理对象控制应用进程，AMS然后通知创建入口Activity实例，并执行他的生命周期方法</li></ol></li></ul></li><li><p>Activity的通信方式</p><ul><li>startActivityForResult</li><li>EventBus</li><li>LocalBroadcastReceiver</li></ul></li></ul><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><ul><li><p>两种启动方式</p><ul><li>bindservice: 绑定服务，调用者挂了，服务也会挂掉。绑定者可以调用服务里面的方法。</li><li>startservice:开启者挂了，服务还在后台长期的运行。<br>开启者不能调用服务里面的方法。</li></ul></li><li><p>IntentService : 会创建独立的worker线程来处理OnHandlerIntent()方法实现的代码，无需处理多线程的问题所有请求处理完成后，IntentService会自动停止。</p></li><li><p>与Activity的通信方式</p><ul><li>Callback加接口</li><li>用Service发广播，activity接收广播</li><li>可以通过bindService的方式，先在Activity里实现一个ServiceConnection接口，并将该接口传递给bindService()方法，在ServiceConnection接口的onServiceConnected()方法里执行相关操作。</li></ul></li></ul><h3 id="BroadcastReciver"><a href="#BroadcastReciver" class="headerlink" title="BroadcastReciver"></a>BroadcastReciver</h3><ul><li>接收原理<ul><li>通过Binder机制向ActivityMangerService注册广播</li><li>通过Binder机制向ActivityMangerService发送广播</li><li>AMS查找符合相应条件的广播，将广播发送到BroadcastReceiver所在的消息队列中。</li><li>BroadcastReceiver所在消息队列拿到此广播后，回调它的onReceive()方法</li></ul></li><li>广播的分类与注册方式<ul><li>分类：分为有序广播或者无序广播，有序广播的广播接收者按照Priority属性值从大-小排序接收。</li><li>注册：动态注册是在代码中注册，跟随组件的生命周期，组件结束前需要动态移除，防止内存溢出。静态注册即使app退出还是可以接收，占内存，耗电大。</li></ul></li></ul><h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><ul><li>ContentProvider中的数据监控机制与Android系统中的广播机制的区别<ul><li>前者通过URI来把通知的发送者和接收者关联在一起，后者是通过Intent</li><li>前者通知注册中心是由ContentService服务来扮演，后者是AMS服务来扮演</li><li>前者接收数据更新通知要继承ContentObserver，后者继承BroadcastReceiver</li></ul></li></ul><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><ul><li>通信方式<ul><li>Fragment调用Activity时，直接使用getActivity()拿到Activity实例</li><li>Actvity调用Fragment时，采用接口回调的形式</li><li>Fragment调用Fragment时，用FindFragmentById()</li></ul></li></ul><h3 id="Handler机制"><a href="#Handler机制" class="headerlink" title="Handler机制"></a>Handler机制</h3><ul><li><p>角色</p><ul><li>Message：消息，线程间通讯的数据单元。</li><li>MessageQueue：消息队列，主要用来向消息队列添加消息和取出消息，先进先出。</li><li>Looper：消息循环器，主要用来把消息分发给相应的处理者。</li><li>Handler：消息处理器，主要向消息队列发送各种消息以及处理各种消息。</li></ul></li><li><p>流程</p><ol><li>Handler通过sendMessage()发送消息Message到消息队列MessageQueue。</li><li>Looper通过loop()不断提取消息，并且将Messeage交给目标handler来进行处理</li><li>调用自身的回调方法handleMessage()来处理Message</li></ol></li></ul><h3 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h3><ul><li>事件分发的三个核心方法：dispatchTouchEvent()，onInterceptTouchEvent()，onTouchEvent()。</li><li>事件分发的顺序:Activity（Window） -&gt; ViewGroup -&gt; View</li><li><p>事件分发核心伪代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父View调用方法入口进行事件分发</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent motionEvent)</span></span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//是否进行拦截</span></span><br><span class="line"><span class="keyword">if</span>(onInterceptTouchEvent(event))&#123;</span><br><span class="line"> consume = onTouchEvent(event);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  consume = child.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="View的绘制"><a href="#View的绘制" class="headerlink" title="View的绘制"></a>View的绘制</h3><ul><li>绘制流程<ul><li>onMeasure()：测量视图，从顶层父view到子view递归调用measure()方法，完成绘制</li><li>onLayout()：确定视图的位置，从顶层父View到子View递归调用layout()方法，父View将上一步measure()方法得到的子View的布局大小和布局参数，将子View放在合适的位置上</li><li>onDraw()：绘制最终的视图，首先ViewRoot创建一个Canvas对象，然后调用onDraw()方法进行绘制。onDraw()方法的绘制流程为：① 绘制视图背景。② 绘制画布的图层。 ③ 绘制View内容。④ 绘制子视图，如果有的话。⑤ 还原图层。⑥ 绘制滚动条。</li></ul></li></ul><h3 id="APK打包流程与安装流程"><a href="#APK打包流程与安装流程" class="headerlink" title="APK打包流程与安装流程"></a>APK打包流程与安装流程</h3><ul><li><p>打包流程</p><p>  主要是资源打包和代码打包</p><ol><li>通过aapt工具将资源文件(包括AndroidManifest.xml、布局文件、各种xml资源等）打包成R.java文件</li><li>处理AIDL文件，生成对应的Java文件</li><li>Javac工具编译项目源码，生成class文件</li><li>DX工具将class文件转换成dex文件，主要完成java字节码转换成Dalvik字节码</li><li>通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件</li><li>利用keystore生成签名文件</li><li>正式版本apk还会使用ZipAlign工具进行对齐处理，可以加快内存映射访问APK文件<br>的速度。</li></ol></li><li><p>安装流程</p><p>  复制APK到/data/app目录下</p><ol><li>资源管理器解析APK里的资源文件</li><li>解析AndroidManifest文件，并在data/data目录下创建对应的应用数据目录</li><li>然后对dex文件进行优化，保存在dalvik-cache目录下</li><li>解析AndroidManifest文件，创建出四大组件，注册到PackageManagerService中</li><li>安装完成后发送安装完成的广播(AppReceiver-PACKAGE_ADDED)。</li></ol></li></ul><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><ul><li><p>Android Binder是用来做进程通信的，Android的各个应用以及系统服务都运行在独立的进程中，它们的通信都依赖于Binder。</p></li><li><p>Linux进程通讯的方式有哪些</p><ul><li>管道：在创建时分配一个page大小的内存，缓存区大小比较有限</li><li>消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；</li><li>共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li><li>Socket：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</li><li>信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；</li></ul></li><li><p>Binder的好处</p><ul><li>高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。</li><li>稳定：Binder基于C/S架构，客户端与服务端彼此独立，稳定性较好。</li><li>安全性：Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理。标记完全是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。</li></ul></li></ul><h3 id="常见的内存泄露"><a href="#常见的内存泄露" class="headerlink" title="常见的内存泄露"></a>常见的内存泄露</h3><ul><li>持有静态的Context（Activity）引用</li><li>持有静态的View引用</li><li>不正确的单例模式，比如单例持有Activity或者Context</li><li>bitmap，io等资源的回收</li><li>内部类&amp;匿名内部类实例无法释放，而内部类又持有外部类的强引用，导致外部类无法释放</li></ul><h3 id="MVC-MVP-MVVM对比分析"><a href="#MVC-MVP-MVVM对比分析" class="headerlink" title="MVC,MVP,MVVM对比分析"></a>MVC,MVP,MVVM对比分析</h3><ul><li>MVC:Activity/Fragment即是View也是，Controller，项目越大，耦合越大。</li><li>MVP:为了达到View和Controller进行解耦，引入了Presenter进行解耦，将视图逻辑和业务逻辑进行分离</li><li>MVVM:使用ViewModel代替Presenter，实现数据与View的双向绑定，可以使用data-bindging将数据绑定进xml中</li></ul><h3 id="热修复的原理"><a href="#热修复的原理" class="headerlink" title="热修复的原理"></a>热修复的原理</h3><ul><li>利用PathClassLoader和DexClassLoader去加载与bug类同名的类，替换掉bug类，进而达到修复bug的目的，原理是在app打包的时候阻止类打上CLASS_ISPREVERIFIED的标志，然后在热修复的时候动态修改BaseDexClassLoader对象间接引用的dexElements，替换掉旧的类.</li></ul><h3 id="Parcelable和Serializable区别"><a href="#Parcelable和Serializable区别" class="headerlink" title="Parcelable和Serializable区别"></a>Parcelable和Serializable区别</h3><ul><li>序列化的两种方式，序列化就是将对象变成二进制流，便于存储和传输。<ul><li>Serializable是java实现的一套序列化方式，可能会触发频繁的IO操作，效率比较低，适合将对象存储到磁盘上的情况。</li><li>Parcelable是Android提供一套序列化机制，它将序列化后的字节流写入到一个共享内存中，其他对象可以从这块共享内存中读出字节流，并反序列化成对象。因此效率比较高，适合在对象间或者进程间传递信息。</li></ul></li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li>Android中常见的4种线程池<ul><li>FixedThreadPool: 线程数量固定的线程池，它只有核心线程</li><li>CachedThreadPool: 线程数量不固定的线程池，它只有非核心线程</li><li>ScheduledThreadPool: 核心线程数量固定，非核心线程数量没有限制的线程池，主要用于执行定时任务和具有固定周期的任务</li><li>SingleThreadPool: 只有一个核心线程的线程池，确保了所有的任务都在同一个线程中按顺序执行。</li></ul></li></ul><h3 id="进程保活"><a href="#进程保活" class="headerlink" title="进程保活"></a>进程保活</h3><ul><li>提升进程的优先级，降低进程被杀死的概率，监控手机锁屏事件，在屏幕锁屏时启动一个像素的Activity，在用户解锁时将Activity销毁掉，前台Activity可以将进程变成前台进程，优先级升级到最高。</li><li>拉活已经被杀死的进程，利用广播拉活Activity。</li></ul>]]></content>
      
      <categories>
          
          <category> Android面试集锦 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android面试集锦 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SWING ! SWING !</title>
      <link href="/home/2017/05/17/swing/"/>
      <url>/home/2017/05/17/swing/</url>
      <content type="html"><![CDATA[<blockquote><p> Swing 控件称为“轻量级控件”,基于AWT的JAVA程序，在不同平台表现一致。(有待考量啊，MAC和WIN上表现上还是有差距的)</p></blockquote><h2 id="Swing-基础构建"><a href="#Swing-基础构建" class="headerlink" title="Swing 基础构建"></a>Swing 基础构建</h2><p>可以简单理解为JFrame 是顶级容器，JPanel是普通容器。</p><ul><li><p>JFrame java的GUI程序的基本思路是以JFrame为基础，它是屏幕上window的对象，能够最大化、最小化、关闭。</p></li><li><p>JPanel Java图形用户界面(GUI)工具包swing中的面板容器类，包含在javax.swing 包中，可以进行嵌套，功能是对窗体中具有相同逻辑功能的组件进行组合，是一种轻量级容器，可以加入到JFrame窗体中。。</p></li></ul><h2 id="Swing-布局管理"><a href="#Swing-布局管理" class="headerlink" title="Swing 布局管理"></a>Swing 布局管理</h2><p>说了这么多，其实还是默认布局，setLayout(null)，然后setBounds()好用。当然前提是，你的桌面客户端不用进行最大化适配，如果要用最大化适配还是需要以下布局。</p><ul><li><p>AbsoluteLayout: 绝对布局允许在界面中以任意位置摆放组件，灵活度很高，主要通过组件位置和尺寸属性进行控制</p></li><li><p>Flowlayout: 布局从左到右，中间放置，一行不下换另一行，一行放多少个取决于宽度，默认居中对齐。（JPanel默认布局）</p></li><li><p>BorderLayout：分为东南西北中五个方位。北和南的组件可以在水平方向上拉伸，东和西的组件可以在垂直方向上拉伸，中心的组件可以同时在水平和垂直的方向上拉伸，填充剩余空间。(JDialog，JFrame,Jwindow的默认布局）</p></li><li><p>GridLayout：网格式的布局，窗口改变的时候，组件的大小也随之改变，每个单元格大小一样，放置组件时需按顺序，不能任意摆放，比较死，不推荐使用</p></li><li><p>CardLayout: 所有卡片叠在一起，每时每刻只能显示一张卡片，常用于切换界面</p></li><li><p>GroupLayout：手写复杂，一般用可视化工具使用，比较强大，可以控件吸附，生成的代码较为复杂</p></li><li><p>GridBagLayout：可完成复杂的布局，IDE有足够的支持，布局过于复杂，有许多约束条件(anchor锚点，ipadx内部填充，Weighty比重)</p></li><li><p>TableLayout：把容器划分为行和列，每一个行列交错形成单元格，组件被添加到容器划分好的单元格里，当容器发生伸缩时候，单元格也随之伸缩，装载在单元格里的组件也相应进行伸缩</p></li></ul><h2 id="Swing-线程安全："><a href="#Swing-线程安全：" class="headerlink" title="Swing 线程安全："></a>Swing 线程安全：</h2><h4 id="线程：-进入时候JVM会启动三个线程"><a href="#线程：-进入时候JVM会启动三个线程" class="headerlink" title="线程：(进入时候JVM会启动三个线程)"></a>线程：(进入时候JVM会启动三个线程)</h4><ul><li>主线程,main入口,也叫初始化线程</li><li>ToolKit线程(也就是键盘，鼠标等事件的捕获线程)</li><li>EDT线程(将ToolKit线程捕获的事件放入一个事件队列，并且将这些事件依次分发出去)</li></ul><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>不能从其他非EDT线程来访问UI组件和事件处理器，否则可能会使程序出现非线程安全问题。</li><li>不能在EDT中执行耗时任务，这会使得GUI事件被阻塞在队列中而得不到处理，使程序失去响应性。</li><li>SwingUtilities提供了最常用的invokeAndWait()方法和invokeLater()方法，其他线程通过这两个方法可以将代码放到事件队列中，当EDT进入该代码块后，就开始执行，并对UI组件进行安全修改。这两个方法又有所区别，invokeLater()方法是异步的，即EDT将将事件放到队列中就返回；而invokeAndWait()方法是同步的，即EDT将事件放到队列中等到其Runnable执行完毕才返回，所以 注意绝对不能使用EDT来调用invokeAndWait()方法，否则会导致死锁发生 。</li></ul><h2 id="Swing-问题"><a href="#Swing-问题" class="headerlink" title="Swing 问题"></a>Swing 问题</h2><p>在开发悦游无限打包工具遇见的一些常见的问题</p><ul><li><p>JLabel.setBackground()不起作用，设置不透明属性:setOpaque(false);</p></li><li><p>在控件绑定数据使用model的时候，默认不选中，想要设置默认选中，设置setSelectedIndex(0)</p></li><li><p>打包成exe软件时，使用运行时环境一般用的是1.6</p></li><li><p>JDialog.setModal(true);会阻塞当前代码，当对话框消失代码从此处继续执行</p></li><li><p>在自定义控件的时候最好把默认属性写上，这样win和mac上才避免出现差异</p></li><li><p>保存数据到本地可以使用java.util.Properties,会以(name=value)形式保存到本地</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>制作一个安装程序(dmg,exe)</title>
      <link href="/home/2017/05/17/pack/"/>
      <url>/home/2017/05/17/pack/</url>
      <content type="html"><![CDATA[<blockquote><p> 项目 -&gt; jar -&gt; exe -&gt; setup.exe（^ ^easy）</p></blockquote><h2 id="接入前准备"><a href="#接入前准备" class="headerlink" title="接入前准备"></a>接入前准备</h2><h3 id="exe4j"><a href="#exe4j" class="headerlink" title="exe4j"></a>exe4j</h3><p>exe4j 是一个帮助你集成JAVA应用程序到Windows操作环境的java可执行文件生产工具, 本文使用版本V4.O(尽量使用最新版本)</p><h3 id="Inno-Setup"><a href="#Inno-Setup" class="headerlink" title="Inno Setup"></a>Inno Setup</h3><p>用脚本方式生成一个可自定义的安装exe包，本文使用版本V5.5.9(尽量使用最新版本)</p><h2 id="生成打包文件"><a href="#生成打包文件" class="headerlink" title="生成打包文件"></a>生成打包文件</h2><ol><li><p>生成jar文件</p><p> 右键工程 &gt; Export &gt; Java Runnable JAR FILE  &gt; 选择入口类PackToolMain &gt; 选择目标输出地址 &gt; Finish(打包过程点击ok忽略其中的警告)</p><p> <img src="0.png" alt="image"></p></li><li><p>拷贝相关文件到打包目录</p><ul><li><p>一个文件夹专用于打包</p><p><img src="1.png" alt="image"></p></li><li><p>将你所需要的资源拷贝到工作空间</p><p><img src="2.png" alt="image"></p></li><li><p>拷贝本地jre运行时环境和icos到打包工具文件夹</p><p><img src="3.png" alt="image"></p></li></ul></li><li><p>利用exe4j生成可执行exe</p><p> <img src="4.png" alt="image"></p><p> <img src="5.png" alt="image"></p><p> <img src="6.png" alt="image"></p><p> <img src="7.png" alt="image"></p><p> <img src="8.png" alt="image"></p><p> <img src="9.png" alt="image"></p><p> <img src="10.png" alt="image"></p><p> <img src="11.png" alt="image"></p><p> 7，8步骤可不设置，将此文件保存到打包路径中config.exe4j，下次可以直接双击使用，点击9自动生成.</p></li><li><p>利用Inno Setup生成安装文件</p><p> Inno Setup打包</p><p> <img src="12.png" alt="image"></p><p> <img src="13.png" alt="image"></p><p> 每次点击run会生成安装包到output文件夹</p><p> 可以使用GUI界面引导生成安装包，也可以使用脚本命令生成，这里是脚本示例:<br> <img src="14.png" alt="image"></p></li></ol>]]></content>
      
      <categories>
          
          <category> PC应用开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PC应用开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RxJava</title>
      <link href="/home/2017/03/20/rx_java/"/>
      <url>/home/2017/03/20/rx_java/</url>
      <content type="html"><![CDATA[<h1 id="Rxjava-1-0"><a href="#Rxjava-1-0" class="headerlink" title="Rxjava 1.0"></a>Rxjava 1.0</h1><blockquote><p>Github官方解释:一个在Java VM上使用可观察的序列来组成异步的、基于事件的程序库；总结三个字就是异步库。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RxJava(异步)响应式编程，本质是观察者模式，以观察者observe和订阅者subscribe为基础的异步响应式开发，Rx是一种编程模式，目标提供一致的编程接口，帮助开发者更方便处理异步数据流。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>编程思路简洁明了</li><li>方便创建事件流和数据流</li><li>可以订阅任何可观察的数据流并执行操作</li><li>使用操作符组合变换数据流</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Observable-被观察者"><a href="#Observable-被观察者" class="headerlink" title="Observable 被观察者"></a>Observable 被观察者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">            subscriber.onNext(<span class="string">"hello rxjava"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Subscriber-观察者"><a href="#Subscriber-观察者" class="headerlink" title="Subscriber 观察者"></a>Subscriber 观察者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Subscriber subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">            tv.setText(str);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><ul><li><p>被观察者普通绑定观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.observable.subscribe(subscriber);</span><br></pre></td></tr></table></figure></li><li><p>被观察者绑定Action1接收事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.observable.subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">               tv.setText(str);</span><br><span class="line">           &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></li><li><p>被观察者Observable使用Just发出事件，被观察者绑定Action1接收事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"hello rxjava"</span>).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">               tv.setText(str);</span><br><span class="line">           &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>Lambda表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"hello rxjava"</span>).subscribe( s -&gt; tv.setText(s));</span><br></pre></td></tr></table></figure></li></ul><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符目的是为了解决对Observable对象的变换问题，操作符用于在Observable和最终的Subscriber之间修改Observable发出的事件    </p><h3 id="Map-操作符"><a href="#Map-操作符" class="headerlink" title="Map 操作符"></a>Map 操作符</h3><p>map()操作符是用于变换Observable对象的，map操作符返回一个Observable对象，在一个Observable对象中多次使用map操作符，最终将数据传给Subscriber。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"hello rxjava"</span>)</span><br><span class="line">                .map(<span class="keyword">new</span> Func1&lt;String, String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> s + <span class="string">"again"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">                        tv.setText(str);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><h3 id="From-操作符"><a href="#From-操作符" class="headerlink" title="From 操作符"></a>From 操作符</h3><p>接收一个集合作为输入，然后每次输出一个元素给subscriber</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line">Observable.from(list).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="FlatMap-操作符"><a href="#FlatMap-操作符" class="headerlink" title="FlatMap 操作符"></a>FlatMap 操作符</h3><p>Observable.flatMap()接收一个Observable的输出作为输入，同时输出另一个Observable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line">Observable&lt;List&lt;String&gt;&gt; observable = Observable.just(list);</span><br><span class="line">observable.flatMap(<span class="keyword">new</span> Func1&lt;List&lt;String&gt;, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(List&lt;String&gt; strings)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Observable.from(strings);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"FlatMap_"</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="Filter-操作符"><a href="#Filter-操作符" class="headerlink" title="Filter 操作符"></a>Filter 操作符</h3><p>过滤，把不符合条件的过滤掉，只留下符合条件的操作符</p><h3 id="Take-操作符"><a href="#Take-操作符" class="headerlink" title="Take 操作符"></a>Take 操作符</h3><p>指定最多输出数量</p><h3 id="doOnNext-操作符"><a href="#doOnNext-操作符" class="headerlink" title="doOnNext 操作符"></a>doOnNext 操作符</h3><p>每次输出一个元素前做一些其他的事情</p>]]></content>
      
      <categories>
          
          <category> Android进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android进阶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Frame 常用框架基础解析</title>
      <link href="/home/2017/01/11/android_frame/"/>
      <url>/home/2017/01/11/android_frame/</url>
      <content type="html"><![CDATA[<h2 id="Android-MVC-MVP-MVVM解析"><a href="#Android-MVC-MVP-MVVM解析" class="headerlink" title="Android MVC MVP MVVM解析"></a>Android MVC MVP MVVM解析</h2><blockquote><p>Android Frame  <a href="https://github.com/KevinRocka/FrameAndroid" target="_blank" rel="noopener">Github地址</a></p></blockquote><h3 id="MVC-Model-View-Controller"><a href="#MVC-Model-View-Controller" class="headerlink" title="MVC (Model-View-Controller)"></a>MVC (Model-View-Controller)</h3><ul><li>Model：数据的获取方式(通过缓存，通过网络，通过本地文件等)以及javabean</li><li>View：控制数据的展示方式(xml文件)和自定义view</li><li>Controller：Model和View层的交互从Model获取完数据，返回给View。在MVC中通常是Activity</li></ul><p>概述：如果要动态的修改某个按钮的状态可见或者不可见，如果不是使用自定义view，那就只有在Activity中控制，造成Activity即是View层，又是Controller层，代码显得过于臃肿，耦合度太高。    </p><h3 id="MVP-Model-View-Presenter"><a href="#MVP-Model-View-Presenter" class="headerlink" title="MVP (Model-View-Presenter)"></a>MVP (Model-View-Presenter)</h3><ul><li>Model 数据的获取方式(通过缓存，通过网络，通过本地文件等)以及javabean</li><li>View  就是纯粹的Activity和Fragment</li><li>Presenter Activity中的UI逻辑抽象成View接口，把业务逻辑抽象成Presenter接口</li></ul><p>概述：view层和model层完全解耦，presenter充当桥梁，presenter层去操作model层，并且将数据返回给view层</p><h3 id="MVVM-Model-View-ViewModel-（DataBinding）"><a href="#MVVM-Model-View-ViewModel-（DataBinding）" class="headerlink" title="MVVM (Model-View-ViewModel)（DataBinding）"></a>MVVM (Model-View-ViewModel)（DataBinding）</h3><ul><li>Model 数据的获取方式(通过缓存，通过网络，通过本地文件等)为ViewModel提供数据</li><li>View Activity，Fragment，Dialog之类都属于View层</li><li>ViewModel 逻辑控制层，负责处理数据和处理View层中的业务逻辑</li></ul><p>概述：DataBinding应该是作为一个绑定器用于绑定实体类与View层，而我们的业务逻辑和View的控制应该抽象我们的ViewModel层中，可以实现视图和逻辑代码的解耦。</p>]]></content>
      
      
        <tags>
            
            <tag> Android实验室 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android开发问题集锦3</title>
      <link href="/home/2016/11/09/qusteion3/"/>
      <url>/home/2016/11/09/qusteion3/</url>
      <content type="html"><![CDATA[<blockquote><p>一些显而易见的问题记录下</p></blockquote><ul><li><p>问题1：java工程解析apk的apkinfo需要用到sdk/build-tools/sdk版本号/aapt以及AXmlResourceParser.jar包，在使用aapt工具的时候报错:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot run program <span class="string">"FxRhAssets/datas/aapt"</span>: error=<span class="number">13</span>, Permission denied</span><br></pre></td></tr></table></figure><p>  出现这个问题是因为本地的aapt权限不够，命令行到本地aapt路径执行：sudo chmod 777 aapt</p></li><li><p>问题2：同上，使用aapt文件也需要适配不同来源，mac版本的aapt不能再win下使用，同理，win版本的appt不能在mac下使用</p></li><li><p>问题3：小米机器在android studio抓不到错误的情况下会报如下的错误，在本项目是因为webview.loadurl(url,header);header没有初始化完全导致，在加载的时候加了一个延迟加载.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">W/WindowAnimator: Failed to dispatch window animation state change.</span><br><span class="line">android.os.DeadObjectException</span><br><span class="line">        at android.os.BinderProxy.transactNative(Native Method)</span><br><span class="line">        at android.os.BinderProxy.transact(Binder.java:<span class="number">506</span>)</span><br><span class="line">        at android.view.IWindow$Stub$Proxy.onAnimationStopped(IWindow.java:<span class="number">534</span>)</span><br><span class="line">        at com.android.server.wm.WindowAnimator.updateWindowsLocked(WindowAnimator.java:<span class="number">289</span>)</span><br><span class="line">        at com.android.server.wm.WindowAnimator.animateLocked(WindowAnimator.java:<span class="number">681</span>)</span><br><span class="line">        at com.android.server.wm.WindowAnimator.access$<span class="number">000</span>(WindowAnimator.java:<span class="number">53</span>)</span><br><span class="line">        at com.android.server.wm.WindowAnimator$<span class="number">1</span>.doFrame(WindowAnimator.java:<span class="number">123</span>)</span><br><span class="line">        at android.view.Choreographer$CallbackRecord.run(Choreographer.java:<span class="number">858</span>)</span><br><span class="line">        at android.view.Choreographer.doCallbacks(Choreographer.java:<span class="number">672</span>)</span><br><span class="line">        at android.view.Choreographer.doFrame(Choreographer.java:<span class="number">605</span>)</span><br><span class="line">        at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:<span class="number">846</span>)</span><br><span class="line">        at android.os.Handler.handleCallback(Handler.java:<span class="number">742</span>)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:<span class="number">95</span>)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:<span class="number">154</span>)</span><br><span class="line">        at android.os.HandlerThread.run(HandlerThread.java:<span class="number">61</span>)</span><br><span class="line">        at com.android.server.ServiceThread.run(ServiceThread.java:<span class="number">46</span>)</span><br><span class="line">I/Timeline: Timeline: Activity_windows_visible id: ActivityRecord&#123;<span class="number">12</span>cbc5c u0 com.miui.home/.launcher.Launcher t5755&#125;</span><br></pre></td></tr></table></figure></li><li><p>问题4：实例化popupwindow后，调用方法showAtLocation()会传参来定位popupwindow显示在哪个布局之上，如果想超出该布局，setClippingEnabled(false);</p></li><li><p>问题5：WindowManager控制弹悬浮窗的时候，一般使用 这个属性：LAYOUT_PARAMS.type = WindowManager.LayoutParams.TYPE_PHONE;部分小米和魅族的机型会不显示。</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//noinspection WrongConstant</span></span><br><span class="line">LAYOUT_PARAMS.type = WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;</span><br></pre></td></tr></table></figure><p>  加上注释编译不会报错，注意一定使用的是getContext()而不是getAaplicationContext()获取WindowManager。</p></li><li><p>问题6：拖动浮标至某处隐藏，若想浮标在上，隐藏的图标在下，隐藏图标建议WindowManager的TYPE为TYPE_APPLICATION_PANEL，浮标建议WindowManager的Type为LAST_APPLICATION_WINDOW，如果位置特殊需要考虑虚拟键盘对位置的影响。</p></li><li><p>问题7：WebView的弹窗有时候内嵌页自己的弹窗会显示不正常，首先可以断定的是因为主题style的样式问题导致，如果可以选择修改样式，就修改样式。否则的话重载onJsAlert()方法。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onJsAlert</span><span class="params">(WebView view, String url, String message, JsResult result)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!TextUtils.isEmpty(message)) &#123;</span><br><span class="line">               ToastUtil.getInstance(mContext).makeText(message);</span><br><span class="line">           &#125;</span><br><span class="line">           result.cancel();<span class="comment">//不添加可能导致界面卡顿</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>问题8:SurfaceView 只能创建一个正方形的自定义View，不能创建一个全屏的长方形的自定义View，使用SurfaceView在其添加传统控件的时候，如果用setZOrderOnTop(true)，SurfaceView会置于最顶层遮盖住原生控件，setZOrderOnTop(true)之后调用了setZOrderMediaOverlay(true)，可能会解决遮罩问题。否则建议使用<a href="http://www.cnblogs.com/youlechang123/p/5693764.html" target="_blank" rel="noopener">原生View来解决</a>.。</p></li><li><p>问题9: 经常使用到自定义view组合方式解耦，使用自定义view的时候一定要使用构造方法的context，不要使用getContext()，否则界面不会显示，也不会报错，写快了经常用getContext()</p></li><li><p>问题10:创建悬浮窗报错，Unable to add window – token null is not for an application，自定义悬浮窗一般不会出问题，初始化的windowmanager的方法要保证使用activity：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WindowManager windowManager = (WindowManager) getActivity().getSystemService(Context.WINDOW_SERVICE);</span><br></pre></td></tr></table></figure></li><li><p>问题11: TextView.setText(Html.fromHtml(text))与实际的HTML不符合，可能是不支持的标签。</p></li><li><p>问题12: JS 与 WebView互相调用不成功，可能JS方法前是否要通过Window属性来进行调用</p></li><li><p>问题13：Error inflating xml。导致这个问题除了构造方法和包名类名路径的完整，也有可能是你自定义view里面某一层的自定义view的包名类名路径的完整性不对。</p></li></ul>]]></content>
      
      <categories>
          
          <category> Android问题集锦 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android问题集锦 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android开发问题集锦1</title>
      <link href="/home/2016/11/09/qusteion1/"/>
      <url>/home/2016/11/09/qusteion1/</url>
      <content type="html"><![CDATA[<blockquote><p>一些显而易见的问题记录下</p></blockquote><ul><li><p>问题1：调用JNI本地方法的时候没权限崩溃</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>-<span class="number">18</span> <span class="number">14</span>:<span class="number">04</span>:<span class="number">44.376</span> <span class="number">13889</span>-<span class="number">13889</span>/downjoy.com.h5game A/art: art/</span><br><span class="line">runtime/check_jni.cc:<span class="number">65</span>] JNI DETECTED ERROR IN APPLICATION: JNI</span><br><span class="line">GetObjectClass called with pending exception <span class="string">'java.lang.SecurityException'</span> <span class="keyword">throw</span> in unknown location</span><br></pre></td></tr></table></figure><p>  出现这个问题是因为本地jni调用了一些方法需要一些权限，这些权限应该在manifest中声明</p></li></ul><ul><li><p>问题2：TextView即使使用了setText()方法的Html.fromHtml(string)也不会正常显示HTML效果</p><p> string中不能带div标签，如果要显示带div标签的字符，使用以下比较好：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mWebView.loadDataWithBaseURL(<span class="keyword">null</span>, mWebViewText, <span class="string">"text/html"</span>,</span><br><span class="line"><span class="string">"utf-8"</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>问题3：小米5 6.0系统在调用系统安装方式的时候，闪退</p><p>  下载安装的文件路径后缀名必须为.apk才能进行安装，不然则会闪退。</p></li><li><p>问题4：使用权限时在6.0以上机器崩溃</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException: No permission to write to /storage/</span><br><span class="line">emulated/<span class="number">0</span>/Download/llnhvrrpg_1477646494236.apk: Neither user <span class="number">10404</span></span><br><span class="line">nor current process has</span><br></pre></td></tr></table></figure><p>  简单的在build.gradle里面修改 targetSdkVersion 21</p></li><li><p>问题5：testin兼容测试报告安装失败“INSTALL_FAILED_OLDER_SDK“</p><p> 简单的在build.gradle里面修改 minSdkVersion 为15合适的版本(4.0)?</p></li><li><p>问题6：WebView崩溃</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Throwable: Error: WebView.destroy() called <span class="keyword">while</span> still attached!</span><br></pre></td></tr></table></figure><p>  修改如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       cleanCookie();</span><br><span class="line">       <span class="keyword">if</span> (mWebView != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mWebView.removeAllViews();</span><br><span class="line">           ((ViewGroup) mWebView.getParent()).removeView(mWebView);</span><br><span class="line">           mWebView.destroy();</span><br><span class="line">           mWebView = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">super</span>.onDestroy();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>问题7 ：DialogFragment异常崩溃</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: Can not perform <span class="keyword">this</span> action after</span><br><span class="line"> onSaveInstanceState with DialogFragment</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数要使用activity.getFragmentManager().beginTransaction()</span></span><br><span class="line">dialogFragment.show(activity.getFragmentManager().beginTransaction(), </span><br><span class="line">                dialogFragment.getClass().getName());</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> Android问题集锦 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android问题集锦 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Android艺术探索》读书笔记 剩余章. Other</title>
      <link href="/home/2016/10/10/android_art_1315_other/"/>
      <url>/home/2016/10/10/android_art_1315_other/</url>
      <content type="html"><![CDATA[<h2 id="CrashHandler"><a href="#CrashHandler" class="headerlink" title="CrashHandler"></a>CrashHandler</h2><ul><li>setDefaultUncaughtExceptionHandler方法！defaultUncaughtHandler是Thread类的静态成员变量，所以如果我们将自定义的UncaughtExceptionHandler设置给Thread的话，那么当前进程内的所有线程都能使用这个UncaughtExceptionHandler来处理异常了。</li><li>一个简易版本的UncaughtExceptionHandler类的子类CrashHandler，CrashHandler的使用方式就是在Application的onCreate方法中设置一下即可</li></ul><h2 id="multidex"><a href="#multidex" class="headerlink" title="multidex"></a>multidex</h2><blockquote><p>Android中单个dex文件所能够包含的最大方法数是65536，这包含Android Framework、依赖的jar以及应用本身的代码中的所有方法。如果方法数超过了最大值，那么编译会报错DexIndexOverflowException。<br>有时方法数没有超过最大值，但是安装在低版本手机上时应用异常终止了，报错Optimization failed。这是因为应用在安装的时候，系统会通过dexopt程序来优化dex文件，在优化的过程中dexopt采用一个固定大小的缓冲区来存储应用中所有方法的信息，这个缓冲区就是LinearAlloc。LinearAlloc缓冲区在新版本的Android系统中大小是8MB或者16MB，但是在Android 2.2和2.3中却只有5MB，当待安装的应用的方法数比较多的时候，尽管它还没有达到最大方法数，但是它的存储空间仍然有可能超过5MB，这种情况下dexopt就会报错导致安装失败。</p></blockquote><ul><li>在Android 5.0之前使用multidex需要引入android-support-multidex.jar包，从Android 5.0开始，系统默认支持了multidex，它可以从apk中加载多个dex。Multidex方案主要针对AndroidStudio和Gradle编译环境。<ul><li>在build.gradle文件中添加multiDexEnabled true</li><li>添加对multidex的依赖</li><li>在代码中添加对multidex的支持，这里有三种方案<ul><li>在AndroidManifest文件中指定Application为MultiDexApplication</li><li>让应用的Application继承自MultiDexApplication</li><li>重写Application的attachBaseContext方法，这个方法要先于onCreate方法执行<ul><li>采用上面的配置之后，如果应用的方法数没有越界，那么Gradle并不会生成多个dex文件；如果方法数越界后，Gradle就会在apk中打包2个或者多个dex文件，具体会打包多少个dex文件要看当前项目的代码规模。在有些情况下，可能需要指定主dex文件中所要包含的类，这个可以通过–main-dex-list选项来实现这个功能。</li><li>Multidex方案可能带来的问题</li><li>应用启动速度会降低，因为应用启动的时候会加载额外的dex文件，所以要避免生成较大的dex文件；</li></ul></li></ul></li><li>需要做大量的兼容性测试，因为Dalvik LinearAlloc的bug，可能导致使用multidex的应用无法在Android 4.0以前的手机上运行。<h2 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h2></li></ul></li><li>动态加载技术又称插件化技术，将应用插件化可以减轻应用的内存和CPU占用，还可以在不发布新版本的情况下更新某些模块。不同的插件化方案各有特色，但是都需要解决三个基础性问题：资源访问，Activity生命周期管理和插件ClassLoader的管理。</li><li>宿主和插件：宿主是指普通的apk，插件是经过处理的dex或者apk。在主流的插件化框架中多采用特殊处理的apk作为插件，处理方式往往和编译以及打包环节有关，另外很多插件化框架都需要用到代理Activity的概念，插件Activity的启动大多数是借助一个代理Activity来实现的。</li><li>资源访问：宿主程序调起未安装的插件apk，插件中凡是R开头的资源都不能访问了，因为宿主程序中并没有插件的资源，通过R来访问插件的资源是行不通的。Activity的资源访问是通过ContextImpl来完成的，它有两个方法getAssets()和getResources()方法是用来加载资源的。具体实现方式是通过反射，调用AssetManager的addAssetPath方法添加插件的路径，然后将插件apk中的资源加载到Resources对象中即可。</li><li>Activity生命周期管理：有两种常见的方式，反射方式和接口方式。反射方式就是通过反射去获取Activity的各个生命周期方法，然后在代理Activity中去调用插件Activity对应的生命周期方法即可。反射方式代码繁琐，性能开销大。接口方式将Activity的生命周期方法提取出来作为一个接口，然后通过代理Activity去调用插件Activity的生命周期方法，这样就完成了插件Activity的生命周期管理。</li><li>插件ClassLoader的管理：为了更好地对多插件进行支持，需要合理地去管理各个插件的DexClassLoader，这样同一个插件就可以采用同一个ClassLoader去加载类，从而避免了多个ClassLoader加载同一个类时所引起的类型转换错误。</li></ul><h2 id="反编译和JNI"><a href="#反编译和JNI" class="headerlink" title="反编译和JNI"></a>反编译和JNI</h2><ul><li>略</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>布局优化<ul><li>删除布局中无用的组件和层级，有选择地使用性能较低的ViewGroup；</li><li>使用<include>、<merge>、<viewstub>等标签：<include>标签主要用于布局重用，<merge>标签一般和<include>配合使用，它可以减少布局中的层级；<viewstub>标签则提供了按需加载的功能，当需要的时候才会将ViewStub中的布局加载到内存，提供了程序的初始化效率。</viewstub></include></merge></include></viewstub></merge></include></li><li><include>标签只支持android:layout_开头的属性，android:id属性例外。</include></li><li>ViewStub 继承自View，它非常轻量级且宽高都为0，它本身不参与任何的布局和绘制过程。实际开发中，很多布局文件在正常情况下不会显示，例如网络异常时的界面，这个时候就没有必要在整个界面初始化的时候加载进行，通过ViewStub可以做到在需要的时候再加载。</li></ul></li><li>绘制优化<ul><li>onDraw中不要创建新的布局对象，因为onDraw会被频繁调用；</li><li>onDraw方法中不要指定耗时任务，也不能执行成千上万次的循环操作。</li></ul></li><li>内存泄露优化<ul><li>可能导致内存泄露的场景很多，例如静态变量、单例模式、属性动画、AsyncTask、Handler等等</li></ul></li><li>响应速度优化和ANR日志分析<ul><li>ANR出现的情况：Activity如果5s内没有响应屏幕触摸事件或者键盘输入事件就会ANR，而BroadcastReceiver如果10s内没有执行完操作也会出现ANR。</li><li>当一个进程发生了ANR之后，系统会在/data/anr目录下创建一个文件traces.txt，通过分析这个文件就能定位ANR的原因。</li></ul></li><li>ListView和Bitmap优化<ul><li>ListView优化：采用ViewHolder并避免在getView方法中执行耗时操作；根据列表的滑动状态来绘制任务的执行频率；可以尝试开启硬件加速来使ListView的滑动更加流畅。</li><li>Bitmap优化：根据需要对图片进行采样    </li></ul></li><li>线程优化<ul><li>采用线程池</li></ul></li><li>其他优化建议<ul><li>不要过多使用枚举，枚举占用的内存空间要比整型大；</li><li>常量请使用static final来修饰；</li><li>使用一些Android特有的数据结构，比如SparseArray和Pair等，他们都具有更好的性能；</li><li>适当使用软引用和弱引用；</li><li>采用内存缓存和磁盘缓存；</li><li>尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄露。</li><li>MAT是功能强大的内存分析工具，主要有Histograms和Dominator Tree等功能</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Android艺术探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android艺术探索 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Android艺术探索》读书笔记 第十二章. Bitmap</title>
      <link href="/home/2016/10/09/android_art_12_bitmap/"/>
      <url>/home/2016/10/09/android_art_12_bitmap/</url>
      <content type="html"><![CDATA[<h2 id="Bitmap高效加载"><a href="#Bitmap高效加载" class="headerlink" title="Bitmap高效加载"></a>Bitmap高效加载</h2><ul><li>BitmapFactory类提供了四类方法：decodeFile、decodeResource、decodeStream和decodeByteArray从不同来源加载出一个Bitmap对象，最终的实现是在底层实现的。</li><li>采用BitmapFactory.Options按照一定的采样率来加载所需尺寸的图片，因为imageview所需的图片大小往往小于图片的原始尺寸</li><li>BitmapFactory.Options的inSampleSize参数，即采样率官方文档指出采样率的取值应该是2的指数，例如k，那么采样后的图片宽高均为原图片大小的 1/k。inSampleSize为2，那么采样后的图片其宽/高均为原图大小的1/2，而像素为原图的1/4，内存也为原图的1/4。</li><li>如何获取图片的采样率呢? <ul><li>将BitmapFactory.Options的inJustDecodeBounds参数设置为true并加载图片</li><li>从BitmapFactory.Options中取出原始的宽高信息，它们对应于outWidth和outHeight</li><li>根据采样率的规则并结合目标View的所需大小计算出采样率inSampleSize</li><li>将BitmapFactory.Options的inJustDecodeBounds参数设为false，然后重新加载图片 </li></ul></li><li>BitmapFactory只会解析图片的原始宽高信息，并不会去真正地加载图片，所以这个操作是轻量级的,需要注意的是，这个时候BitmapFactory获取的图片宽高信息和图片的位置以及程序运行的设备有关，这都会导致BitmapFactory获取到不同的结果。</li></ul><h2 id="Bitmap缓存策略"><a href="#Bitmap缓存策略" class="headerlink" title="Bitmap缓存策略"></a>Bitmap缓存策略</h2><blockquote><p>最常用的缓存算法是LRU，核心是当缓存满时，会优先淘汰那些近期最少使用的缓存对象，系统中采用LRU算法的缓存有两种：LruCache(内存缓存)和DiskLruCache(磁盘缓存)。</p></blockquote><ul><li>几种引用<ul><li>强引用(StrongReference)：直接对象引用</li><li>软引用(SoftReference)：当一个对象只有软引用存在时，系统内存不足对象会被gc回收</li><li>弱引用(WeakReference)：当一个对象只有弱引用存在时，对象随时会被系统回收</li></ul></li><li>LruCache是Android 3.1才有的，通过support-v4兼容包可以兼容到早期的Android版本。LruCache类是一个线程安全的泛型类，它内部采用一个LinkedHashMap以强引用的方式存储外界的缓存对象，其提供了get和put方法来完成缓存的获取和添加操作，当缓存满时，LruCache会移除较早使用的缓存对象，然后再添加新的缓存对象。</li><li>DiskLruCache磁盘缓存，它不属于Android sdk的一部分，DiskLruCache的创建、缓存查找和缓存添加操作</li></ul><h2 id="ImageLoader的使用"><a href="#ImageLoader的使用" class="headerlink" title="ImageLoader的使用"></a>ImageLoader的使用</h2><ul><li>避免发生列表item错位的解决方法<ul><li>给显示图片的imageview添加tag属性，值为要加载的图片的目标url，显示的时候判断一下url是否匹配。</li></ul></li><li>化列表的卡顿现象<ul><li>不要在getView中执行耗时操作，不要在getView中直接加载图片，否则肯定会导致卡顿；</li><li>控制异步任务的执行频率：在列表滑动的时候停止加载图片，等列表停下来以后再加载图片；</li><li>使用硬件加速来解决莫名的卡顿问题，给Activity添加配置android:hardwareAccelerated=”true”；</li><li>解决大范围上下滑动,异步任务会造成线程池的拥堵并随即带来大量的UI更新操作，解决办法是在OnScrollListener的OnScrollStateChanged方法中判断是否滑动，停止滑动在加载</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Android艺术探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android艺术探索 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Android艺术探索》读书笔记 第十一章. ThreadPoolExecutor</title>
      <link href="/home/2016/10/09/android_art_11_threadpoolexecutor/"/>
      <url>/home/2016/10/09/android_art_11_threadpoolexecutor/</url>
      <content type="html"><![CDATA[<h2 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h2><ul><li><p>在Java中默认情况下一个进程只有一个线程，也就是主线程(UI线程)，其他线程都是子线程(工作线程)。Android中的主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。线程的创建和销毁的开销较大，所以如果一个进程要频繁地创建和销毁线程的话，都会采用线程池的方式。</p></li><li><p>从Android 3.0开始，系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做是为了避免主线程由于被耗时操作所阻塞从而出现ANR现象。</p></li></ul><h2 id="Android的线程形态"><a href="#Android的线程形态" class="headerlink" title="Android的线程形态"></a>Android的线程形态</h2><ul><li><p>AsyncTask</p><ul><li><p>AsyncTask注意事项</p><ul><li>AsyncTask的类必须在主线程中加载，这个过程在Android 4.1及以上版本中已经被系统自动完成。</li><li>AsyncTask 中doInBackground不是在主线程执行的。</li><li>AsyncTask对象必须在主线程中创建，execute方法必须在UI线程中调用。</li><li>一个AsyncTask对象只能执行一次，即只能调用一次execute方法，否则会报运行时异常。</li></ul></li><li><p>AsyncTask源码历史</p><ul><li>在Android 1.6之前，AsyncTask是串行执行任务的，Android 1.6的时候AsyncTask开始采用线程池并行处理任务，但是从Android 3.0开始，为了避免AsyncTask带来的并发错误，AsyncTask又采用一个线程来串行执行任务。尽管如此，在Android 3.0以及后续版本中，我们可以使用AsyncTask的executeOnExecutor方法来并行执行任务。但是这个方法是Android 3.0新添加的方法，并不能在低版本上使用。</li></ul></li><li><p>AsyncTask工作原理</p><ul><li>AsyncTask中有两个线程池：SerialExecutor和THREAD_POOL_EXECUTOR。前者是用于任务的排队，默认是串行的线程池；后者用于真正执行任务。AsyncTask中还有一个Handler，即InternalHandler，用于将执行环境从线程池切换到主线程。AsyncTask内部就是通过InternalHandler来发送任务执行的进度以及执行结束等消息。</li><li>AsyncTask排队执行过程：系统先把参数Params封装为FutureTask对象，它相当于Runnable；接着将FutureTask交给SerialExecutor的execute方法，它先把FutureTask插入到任务队列tasks中，如果这个时候没有正在活动的AsyncTask任务，那么就会执行下一个AsyncTask任务，同时当一个AsyncTask任务执行完毕之后，AsyncTask会继续执行其他任务直到所有任务都被执行为止。</li></ul></li></ul></li><li><p>HandlerThread</p><ul><li>HandlerThread继承了Thread，就是一种可以使用Handler的Thread，它的实现就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环。这样在实际的使用中就允许在HandlerThread中创建Handler了，和普通的Thread有显著不同，普通Thread主要用于run执行耗时任务，而handlerThread内部创建了消息队列，外界可以通过Handler的消息方式通知HandlerThread执行一个具体的任务。HandlerThread的run方法是一个无限循环，因此当明确不需要再使用HandlerThread的时候，可以通过它的quit或者quitSafely方法来终止线程的执行。HandlerThread的最主要的应用场景就是用在IntentService中。</li></ul></li><li><p>IntentService</p><ul><li>IntentService是一个继承自Service的抽象类，要使用它就要创建它的子类。IntentService适合执行一些高优先级的后台任务，这样不容易被系统杀死。IntentService的onCreate方法中会创建HandlerThread，并使用HandlerThread的Looper来构造一个Handler对象ServiceHandler，这样通过ServiceHandler对象发送的消息最终都会在HandlerThread中执行。IntentService会将Intent封装到Message中，通过ServiceHandler发送出去，在ServiceHandler的handleMessage方法中会调用IntentService的抽象方法onHandleIntent，所以IntentService的子类都要是实现这个方法。</li><li>stopSelf()立刻停止服务，stopSelf(int startiD)会等所有的消息都处理完毕后终止服务。一般来说，stopSelf(int startID)尝试停止服务之前会判断最近启动服务端的次数和startId相等，如果相等立刻停止服务，不相等就不停止服务，详见AMS的stopServiceToken方法</li></ul></li></ul><h2 id="Android的线程池"><a href="#Android的线程池" class="headerlink" title="Android的线程池"></a>Android的线程池</h2><ul><li><p>线程池好处</p><ul><li>重用线程，避免线程的创建和销毁带来的性能开销；</li><li>能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象；</li><li>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li></ul></li><li><p>ThreadPoolExecutor</p><blockquote><p>Executor只是一个接口，真正的线程池是ThreadPoolExecutor。ThreadPoolExecutor提供了一系列参数来配置线程池，通过不同的参数可以创建不同的线程池，Android的线程池都是通过Executors提供的工厂方法得到的。</p></blockquote><ul><li><p>构造参数</p><ul><li>corePoolSize：核心线程数，默认情况下，核心线程会在线程中一直存活，即使他们处于闲置状态，如果将ThreadPoolExecutor的allowCoreThreadTimeout设置为true，闲置的核心线程在等待新任务到来时会有超时策略，时间间隔由keepAliveTime指定，等待时间超过keepAliveTime指定的时长后，核心线程会被终止；</li><li>maximumPoolSize：最大线程数，当活动线程数达到这个数值后，后续的任务将会被阻塞；keepAliveTime：非核心线程闲置时的超时时长，超过这个时长，闲置的非核心线程就会被回收；</li><li>keepAliveTime：非核心线程闲置时的超时时长，超过这个时长，闲置的非核心线程就会被回收；</li><li>unit：用于指定keepAliveTime参数的时间单位，有TimeUnit.MILLISECONDS、TimeUnit.SECONDS、TimeUnit.MINUTES等；</li><li>workQueue：任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中；</li><li>threadFactory：线程工厂，为线程池提供创建新线程的功能。它是一个接口，它只有一个方法Thread newThread(Runnable r)；</li><li>RejectedExecutionHandler：当线程池无法执行新任务时，可能是由于任务队列已满或者是无法成功执行任务，这个时候就会调用这个Handler的rejectedExecution方法来通知调用者，默认情况下，rejectedExecution会直接抛出一个rejectedExecutionException。</li></ul></li><li><p>执行任务的规则：</p><ul><li>如果线程池中的线程数未达到核心线程的数量，那么会直接启动一个核心线程来执行任务；</li><li>如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行；</li><li>如果在步骤2中无法将任务插入到的任务队列中，可能是任务队列已满，这个时候如果线程数量没有达到规定的最大值，那么会立刻启动非核心线程来执行这个任务；</li><li>如果步骤3中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。</li></ul></li><li><p>AsyncTask的THREAD_POOL_EXECUTOR线程池的配置：</p><ul><li>corePoolSize=CPU核心数+1；</li><li>maximumPoolSize=2倍的CPU核心数+1；</li><li>核心线程无超时机制，非核心线程在闲置时间的超时时间为1s；</li><li>任务队列的容量为128。</li></ul></li></ul></li></ul><ul><li><p>Android中常见的4类具有不同功能特性的线程池：</p><ul><li><p>FixedThreadPool：线程数量固定的线程池，它只有核心线程；</p></li><li><p>CachedThreadPool：线程数量不固定的线程池，它只有非核心线程；</p></li><li><p>ScheduledThreadPool：核心线程数量固定，非核心线程数量没有限制的线程池，主要用于执行定时任务和具有固定周期的任务；</p></li><li><p>SingleThreadPool：只有一个核心线程的线程池，确保了所有的任务都在同一个线程中按顺序执行。 </p></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Android艺术探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android艺术探索 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Android艺术探索》读书笔记 第十章. Message</title>
      <link href="/home/2016/10/08/android_art_10_message/"/>
      <url>/home/2016/10/08/android_art_10_message/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>Handler的作用轻松的将一个任务轻松的切换到Handler所在线程中执行，更新UI只是其中的一个</p></li><li><p>Android 消息机制主要是指Handler的运行机制，Handler运行需要MessageQueue和Looper的支撑。MessageQueue名字叫消息队列，真正的数据结构是单链表来存储数据。Looper会以无限勋魂的形式去查是否有新消息，有就处理消息，否则一直等待着。</p></li><li><p>Looper中有个ThreadLocal，它并不是线程，作用是每个线程中存储数据，在不同线程中互不干扰的提供数据。通过ThreadLocal可以轻松拿到每个线程的Looper。线程默认没有Looper的。如果需要使用Handler必须为线程创建Looper</p></li></ul><h2 id="Android消息机制概述"><a href="#Android消息机制概述" class="headerlink" title="Android消息机制概述"></a>Android消息机制概述</h2><ul><li><p>子线程访问UI跑出异常，这个操作检测是在ViewRootImpl中的checkThread()进行验证的，就是经常遇到的Only the original thread that created a view hierarchy can touch this views</p></li><li><p>Handler的创建会采用当前线程的Looper来构建内部的消息循环系统，没有Looper会报错，can’t create handler inside thread that has not called Looper.prepare()</p></li><li><p>Handler可以用post方法将一个Runnable投递到Handler内部的Looper中去处理，也可以用send方法发送一个消息投递到消息队列中，这个消息同样会在Looper中去处理，其实post最终还是调用了send方法。注意：Looper是运行在创建Handler所在的线程中的，这样一来Handler的业务逻辑就被切换到创建Handler的线程中去了。</p></li></ul><h2 id="Android消息机制分析"><a href="#Android消息机制分析" class="headerlink" title="Android消息机制分析"></a>Android消息机制分析</h2><ul><li><p>ThreadLocal</p><ul><li>是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑使用ThreadLocal。 对于Handler来说，它需要获取当前线程的Looper，而Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以实现Looper在线程中的存取了。</li><li>不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前的ThreadLocal索引去在查找对应的value值。</li><li>ThreadLocal是一个泛型类，ThreadLocal数据的存储规则：ThreadLocal的值在table数组中的存储位置总是ThreadLocal的索引+1的位置。ThreadLocal的set和get方法看出，所操作的对象都是当前线程的localValues对象的table数组，不同线程访问同一个Threadlocal的set和get方法，对ThreadLocal所做的读/写操作仅限于各自线程内部</li></ul></li><li><p>MessageQueue</p><ul><li>包含两个操作，插入（enqueueMessage）,读取（next）;读取操作是从消息队列中取出一条消息并从消息队列移除，MessageQueue实际上是一个单链表的数据结构来维护消息队列</li><li>next方法是一个无线循环的方法，如果消息队列没有消息，next方法会一直阻塞在这里。当有新消息来的时候，next方法会返回这条消息并且从单链表中删除。</li></ul></li><li><p>Looper</p><ul><li>Looper扮演者消息循环的角色，不停地从MessageQueue中查看是否有新消息，有新消息立即处理，没有就阻塞在那里</li><li><p>为一个线程创建Looper的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="string">"test"</span>)&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Looper.prepare();<span class="comment">//创建looper</span></span><br><span class="line">     Handler handler = <span class="keyword">new</span> Handler();<span class="comment">//可以创建handler了</span></span><br><span class="line">     Looper.loop();<span class="comment">//开始looper循环</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></li><li><p>Looper 的quit(直接退出Looper) 和 quitSafely(设定一个标记，消息处理完才退出)，Looper退出之后，通过Handler发送的消息就会失败，这个时候Handler的send方法会返回false。</p></li><li>在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待的状态，而如果退出Looper以后，这个线程就会立刻终止，因此建议不需要的时候终止Looper。</li><li>Looper的loop方法会调用MessageQueue的next方法来获取新消息，而next是一个阻塞操作，当没有消息时，next方法会一直阻塞着在那里，这也导致了loop方法一直阻塞在那里。如果MessageQueue的next方法返回了新消息，Looper就会处理这条消息：msg.target.dispatchMessage(msg)，其中的msg.target就是发送这条消息的Handler对象。这样Handler发送的消息最终又给它的dispatchMessage方法来处理了。但是这里不同的是，Handler的dispatchMessage方法是在创建Handler时所使用Looper中执行，这样就成功的将代码逻辑切换到指定线程中</li></ul></li><li><p>Handler </p><ul><li><p>消息处理</p><pre><code class="java"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>{        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) {            handleCallback(msg);<span class="comment">//当message是runnable的情况，也就是Handler的post方法传递的参数，这种情况下直接执行runnable的run方法</span>        } <span class="keyword">else</span> {            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) {<span class="comment">//如果创建Handler的时候是给Handler设置了Callback接口的实现，那么此时调用该实现的handleMessage方法</span>                <span class="keyword">if</span> (mCallback.handleMessage(msg)) {                    <span class="keyword">return</span>;                }            }            handleMessage(msg);<span class="comment">//如果是派生Handler的子类，就要重写handleMessage方法，那么此时就是调用子类实现的handleMessage方法</span>        }    }</code></pre></li><li>两种方式实现Handler：<ul><li>Handler handler = new Handler(callback)，callback中处理消息</li><li>派生一个Handler的子类并重写handleMessage</li></ul></li></ul></li></ul><h2 id="主线程消息循环"><a href="#主线程消息循环" class="headerlink" title="主线程消息循环"></a>主线程消息循环</h2><ul><li><p>Android的主线程就是ActivityThread，主线程的入口方法就是main，其中调用了Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue，并通过Looper.loop()方法来开启主线程的消息循环。主线程内有一个Handler，即ActivityThread.H，它定义了一组消息类型，主要包含了四大组件的启动和停止等过程</p></li><li><p>ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方法完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。</p></li></ul>]]></content>
      
      <categories>
          
          <category> Android艺术探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android艺术探索 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Android艺术探索》读书笔记 第八章. Window</title>
      <link href="/home/2016/08/15/android_art_8_window/"/>
      <url>/home/2016/08/15/android_art_8_window/</url>
      <content type="html"><![CDATA[<h2 id="Window和WindowManager"><a href="#Window和WindowManager" class="headerlink" title="Window和WindowManager"></a>Window和WindowManager</h2><ul><li>Window实际是View的直接管理者。</li><li>Window是抽象类，具体实现是PhoneWindow，通过WindowManager就可以创建Window。<br>WindowManager是外界访问Window入口，Window具体实现是在WindowManagerService中，WindowManager和WindoManagerService的交互是一个IPC。所有视图都是附加在Window上的</li><li>WindowManager.LayoutParams的Flags和Type参数<ul><li>Flags：<ul><li>FLAG_NOT_FOCUSABLE：表示window不需要获取焦点，也不需要接收各种输入事件。此标记会同时启用FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层的具有焦点的window；</li><li>FLAG_NOT_TOUCH_MODAL：在此模式下，系统会将window区域外的单击事件传递给底层的window，当前window区域内的单击事件则自己处理，一般都需要开启这个标记；</li><li>FLAG_SHOW_WHEN_LOCKED：开启此模式可以让Window显示在锁屏的界面上</li></ul></li><li>Type(表示window的类型，层级范围越大越在上面)：<ul><li>应用window:对应着一个Activity，层级范围是1~99</li><li>子window:不能独立存在，需要附属在特定的父window之上,比如Dilaog，层级范围是1000~1999</li><li>系统window:Toast和系统状态栏这些都是系统window，声明权限才能创建的window，层级范围是2000~2999</li></ul></li></ul></li></ul><h2 id="Window的内部机制"><a href="#Window的内部机制" class="headerlink" title="Window的内部机制"></a>Window的内部机制</h2><ul><li><p>Window是一个抽象的概念，不是实际存在的，它也是以View的形式存在。在实际使用中无法直接访问Window，只能通过WindowManager才能访问Window。每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系。</p></li><li><p>Window的添加、删除和更新过程都是IPC过程，WindowManager的实现类对于addView、updateView和removeView方法都是委托给WindowManagerGlobal类，该类保存了很多List，window对应view的List，window对应的ViewRootImpl的List，之后的操作交给了ViewRootImpl处理，接着会通过WindowSession完成Window的添加过程，是一个IPC调用，最终通过WindowManagerService完成window添加的</p></li></ul><h2 id="Window的创建过程"><a href="#Window的创建过程" class="headerlink" title="Window的创建过程"></a>Window的创建过程</h2><ul><li>Activity的window创建过程<ul><li>通过PolicyManager的makeNewWindow方法创建Window</li><li>Window创建好之后，通过PhoneWindow的setContetnView将Activity与Window进行关联。</li><li>Tips:<ul><li>Activity的启动过程很复杂，最终会由ActivityThread中的performLaunchActivity来完成整个启动过程，在这个方法内部会通过类加载器创建Activity的实例对象，并调用它的attach方法为其关联运行过程中所依赖的一系列上下文环境变量；</li><li>Activity实现了Window的Callback接口，当window接收到外界的状态变化时就会回调Activity的方法，例如onAttachedToWindow、onDetachedFromWindow、dispatchTouchEvent等；</li><li>Activity的Window是由PolicyManager来创建的，它的真正实现是Policy类，它会新建一个PhoneWindow对象，Activity的setContentView的实现是由PhoneWindow来实现的；</li><li>Activity的顶级View是DecorView，它本质上是一个FrameLayout。如果没有DecorView，那么PhoneWindow会先创建一个DecorView，然后加载具体的布局文件并将view添加到DecorView的mContentParent中，最后就是回调Activity的onContentChanged通知Activity视图已经发生了变化；</li><li>还有一个步骤是让WindowManager能够识别DecorView，在ActivityThread调用handleResumeActivity方法时，首先会调用Activity的onResume方法，然后会调用makeVisible方法，这个方法中DecorView真正地完成了添加和显示过程。</li></ul></li></ul></li><li>Dialog的Window创建过程<ul><li>通过PolicyManager的makeNewWindow方法创建Window</li><li>初始化DecorView并将Dialog的视图添加到DecorView中</li><li>将DecorView添加到Window中显示<br>想要创建一个Application Context的Dialog 只需要申请权限以及设置dialog.getWindow().setType(LayoutParams.TYPE_SYSTEM_ERROR)</li></ul></li><li>Toast的Window创建过程<ul><li>Toast内部有两类IPC: Toast访问NotificationManagerService(NMS)；NMS访问Toast的TN接口</li><li>Toast属于系统Window，内部视图mNextView一种为系统默认样式，另一种通过setView方法来指定一个自定义View</li><li>TN是一个Binder类，NMS处理Toast的显示和隐藏时候会跨进程回调TN的方法，所以TN运行在Binder线程池中，所以需要handler切换到当前发送Toast请求的线程中，没有Looper的线程无法弹出toast</li><li>Toast的show()调用了NMS的enqueueToast(),该方法先将Toast请求封装到ToastRecord并放入mToastQueue队列，(非系统应用最多50个)，NMS通过showNextToastLocked()来显示当前View，Toast显示由ToastRecord的callback方法中show完成，callback其实是TN对象远程Binder，最终调用的是TN方法，并行运行在发起Toast请求应用的Binder线程池中</li><li>显示和隐藏都通过ToastRecord的callback回调TN的show，hide方法，然后通过handler发送两个runnable，里面的handleShow和handleHide方法是真正完成显示和隐藏Toast的地方。handleShow将Toast的视图添加到window中，handleHide方法将Toast视图从Window中移除</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Android艺术探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android艺术探索 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Android艺术探索》读书笔记 第九章. Componentswork</title>
      <link href="/home/2016/08/15/android_art_9_componentswork/"/>
      <url>/home/2016/08/15/android_art_9_componentswork/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>Activity的主要作用是展示一个界面并和用户交互，扮演前台界面的角色，可由显式或者隐式Intent来启动</p></li><li><p>Service是一种计算型组件，用于在后台执行一系列计算任务。尽管service是用于后台执行计算的，但是它本身是运行在主线程中的，因此耗时的后台计算仍然需要在单独的线程中去完成。Service组件有两种状态：启动状态和绑定状态。当service处于绑定状态时，外界可以很方便的和service进行通信，而在启动状态中是不可与外界通信的。</p></li><li><p>BroadcastReceiver是一种消息型组件，既可以在AndroidManifest文件中注册，也可以都在代码中注册，用于在不同的组件乃至不同的应用之间传递消息，它工作在系统内部。广播有两种注册方式：静态注册和动态注册。静态注册是在AndroidManifest中注册，在应用安装的时候会被系统解析，这种广播不需要应用启动就可以收到相应的广播。动态注册需要通过Context.registerReceiver()来注册，这种广播需要应用启动才能注册并接收广播。BroadcastReceiver组件一般来说不需要停止，它也没有停止的概念。</p></li><li><p>ContentProvider是一种数据共享型组件，调用不需要借助Intent，其他三个组件需要，用于向其他组件乃至其他应用共享数据。ContentProvider中的insert、delete、update、query方法需要处理好线程同步，因为这几个方法是在Binder线程池中被调用的，另外ContentProvider组件也不需要手动停止。</p></li></ul><h2 id="Activity-工作流程"><a href="#Activity-工作流程" class="headerlink" title="Activity 工作流程"></a>Activity 工作流程</h2><ul><li><p>ApplicationThread是ActivityThread的一个内部类，它继承自ApplicationThreadNative，而ApplicationThreadNative继承自Binder并实现了IApplicationThread接口，ApplicationThreadNative的作用其实就和系统为AIDL文件生成的类是一样的。</p></li><li><p>ActivityManagerService(AMS)继承自ActivityManagerNative，而ActivityManagerNative继承自Binder并实现了IActivityManager这个Binder接口，因此AMS也是一个Binder。</p></li><li><p>一个应用只有一个Application对象，它的创建也是通过Instrumentation来完成的，这个过程和Activity对象的创建过程一样，都是通过类加载器来实现的。</p></li><li><p>ContextImpl是Context的具体实现，ContextImpl是通过Activity的attach方法来和Activity建立关联的，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当window接收到外部输入事件后就可以将事件传递给Activity。 [这里可能有误，应该是Activity将事件传递给window]</p></li><li><p>Activity启动过程<br><img src="Activity.png" alt="image"></p></li></ul><h2 id="Service-工作流程"><a href="#Service-工作流程" class="headerlink" title="Service 工作流程"></a>Service 工作流程</h2><ul><li><p>Service分为两种工作状态,两种状态可以共存。</p><p>  一种是启动状态，用于后台计算；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startService（intentService）</span><br></pre></td></tr></table></figure><p>另一种是绑定状态，用于与其他组件和Service交互。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bindService (intetService, mServiceConnetcion ,BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure><ul><li><p>启动过程<br><img src="Service1.png" alt="image"></p></li><li><p>绑定过程<br><img src="Service2.png" alt="image"></p></li></ul><h2 id="BroadcastReceiver-工作流程"><a href="#BroadcastReceiver-工作流程" class="headerlink" title="BroadcastReceiver 工作流程"></a>BroadcastReceiver 工作流程</h2><ul><li>广播的发送有几种类型：普通广播，有序广播，粘性广播，发送接收过程是类似的</li><li>一个应用处于停止态分为两种类型：1.应用安装未运行；2.应用被手动或被其他应用强停了，从Android3.1开始，处于停止状态的应用无法接收开机广播</li><li>广播静态注册在应用安装的时候由系统自动完成注册，具体是由PackageManagerService完成整个注册过程，其他三大组件也是在应用安装时PMS解析并注册的。</li><li><p>动态注册过程<br>   <img src="BroadcastReceiver1.png" alt="image"></p></li><li><p>发送和接收过程<br>   <img src="BroadcastReceiver2.png" alt="image"></p></li></ul><h2 id="ContentProvider-工作流程"><a href="#ContentProvider-工作流程" class="headerlink" title="ContentProvider 工作流程"></a>ContentProvider 工作流程</h2><p>ContentProvider启动流程：<br>    <img src="ContentProvider.png" alt="image"></p><ul><li><p>启动流程：</p><ul><li>当一个应用启动时，入口方法是ActivityThread的main方法，其中创建ActivityThread的实例并创建主线程的消息队列</li><li>ActivityThread的attach方法中会远程调用ActivityManagerService的attachApplication，并将ApplicationThread提供给AMS，ApplicationThread主要用于ActivityThread和AMS之间的通信；</li><li>ActivityManagerService的attachApplication会调用ApplicationThread的bindApplication方法，这个方法会通过H切换到ActivityThread中去执行，即调用handleBindApplication方法；</li><li>handleBindApplication方法会创建Application对象并加载ContentProvider，注意是先加载ContentProvider，然后调用Application的onCreate方法。</li></ul></li><li><p>当ContentProvider所在的进程启动的时候，它会同时被启动并被发布到AMS中，这个时候它的onCreate要先去Application的onCreate执行。</p></li><li><p>ContentProvider的android:multiprocess属性决定它是否是单实例，默认值是false，也就是默认是单实例。当设置为true时，每个调用者的进程中都存在一个ContentProvider对象。</p></li><li><p>当调用ContentProvider的insert、delete、update、query方法中的任何一个时，如果ContentProvider所在的进程没有启动的话，那么就会触发ContentProvider的创建，并伴随着ContentProvider所在进程的启动。下图是ContentProvider的query操作的大致过程：</p></li></ul>]]></content>
      
      <categories>
          
          <category> Android艺术探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android艺术探索 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Android艺术探索》读书笔记 第六章. Drawable</title>
      <link href="/home/2016/08/14/android_art_6_drawable/"/>
      <url>/home/2016/08/14/android_art_6_drawable/</url>
      <content type="html"><![CDATA[<h2 id="Drawable简介"><a href="#Drawable简介" class="headerlink" title="Drawable简介"></a>Drawable简介</h2><ul><li><p>Android的Drawable表示的是一种可以在Canvas上进行绘制的概念，它的种类很多，最常见的就是图片和颜色了。它有两个重要的优点：一是比自定义view要简单；二是非图片类型的drawable占用空间小，利于减小apk大小。</p></li><li><p>Drawable是抽象类，是所有Drawable对象的基类。</p></li><li><p>Drawable的内部宽/高可以通过getIntrinsicWidth和getIntrinsicHeight方法获取，但是并不是所有Drawable都有内部宽/高。图片Drawable的内部宽高就是图片的宽高，但是颜色Drawable就没有宽高的概念，它一般是作为view的背景，所以会去适应view的大小，这两个方法都是返回-1。</p></li></ul><h2 id="Drawable分类"><a href="#Drawable分类" class="headerlink" title="Drawable分类"></a>Drawable分类</h2><ul><li>BitmapDrawable表示一张图片，对应xml标签</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bitmap</span> / <span class="attr">nine-patch</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">"@[package:]drawable/drawable_resource"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:antialias</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:dither</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:filter</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">[</span>"<span class="attr">top</span>" | "<span class="attr">bottom</span>" | "<span class="attr">left</span>" | "<span class="attr">right</span>" | "<span class="attr">center_vertical</span>" |</span></span><br><span class="line"><span class="tag">                      "<span class="attr">fill_vertical</span>" | "<span class="attr">center_horizontal</span>" | "<span class="attr">fill_horizontal</span>" |</span></span><br><span class="line"><span class="tag">                      "<span class="attr">center</span>" | "<span class="attr">fill</span>" | "<span class="attr">clip_vertical</span>" | "<span class="attr">clip_horizontal</span>"]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:tileMode</span>=<span class="string">[</span>"<span class="attr">disabled</span>" | "<span class="attr">clamp</span>" | "<span class="attr">repeat</span>" | "<span class="attr">mirror</span>"] /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>android:antialias：是否开启图片抗锯齿功能。开启后会让图片变得平滑，同时也会一定程度上降低图片的清晰度，建议开启；</li><li>android:dither：是否开启抖动效果。当图片的像素配置和手机屏幕像素配置不一致时，开启这个选项可以让高质量的图片在低质量的屏幕上还能保持较好的显示效果，建议开启。</li><li>android:filter：是否开启过滤效果。当图片尺寸被拉伸或压缩时，开启过滤效果可以保持较好的显示效果，建议开启；</li><li>android:gravity：当图片小于容器的尺寸时，设置此选项可以对图片进行定位。</li><li>android:tileMode：平铺模式，有四种选项[“disabled” | “clamp” | “repeat” | “mirror”]。当开启平铺模式后，gravity属性会被忽略。repeat是指水平和竖直方向上的平铺效果；mirror是指在水平和竖直方向上的镜面投影效果；clamp是指图片四周的像素会扩展到周围区域，这个比较特别。</li><li>NinePatchDrawable，表示一张.9图， ,在bitmap标签中也可以使用.9图。</li><li>ShapDrawable表示以颜色构造的图形，可以纯色，也可以渐变。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span>    </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>    </span></span><br><span class="line"><span class="tag">    <span class="attr">android:shape</span>=<span class="string">[</span>"<span class="attr">rectangle</span>" | "<span class="attr">oval</span>" | "<span class="attr">line</span>" | "<span class="attr">ring</span>"] &gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span>        //当<span class="attr">shape</span>为<span class="attr">rectangle</span>时使用</span></span><br><span class="line"><span class="tag">        <span class="attr">android:radius</span>=<span class="string">"integer"</span>        //半径值会被后面的单个半径属性覆盖，默认为<span class="attr">1dp</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:topLeftRadius</span>=<span class="string">"integer"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:topRightRadius</span>=<span class="string">"integer"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:bottomLeftRadius</span>=<span class="string">"integer"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:bottomRightRadius</span>=<span class="string">"integer"</span> /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">gradient</span>       //渐变</span></span><br><span class="line"><span class="tag">        <span class="attr">android:angle</span>=<span class="string">"integer"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:centerX</span>=<span class="string">"integer"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:centerY</span>=<span class="string">"integer"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:centerColor</span>=<span class="string">"integer"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:endColor</span>=<span class="string">"color"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:gradientRadius</span>=<span class="string">"integer"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:startColor</span>=<span class="string">"color"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:type</span>=<span class="string">[</span>"<span class="attr">linear</span>" | "<span class="attr">radial</span>" | "<span class="attr">sweep</span>"]        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:useLevel</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"] /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">padding</span>        //内边距</span></span><br><span class="line"><span class="tag">        <span class="attr">android:left</span>=<span class="string">"integer"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:top</span>=<span class="string">"integer"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:right</span>=<span class="string">"integer"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:bottom</span>=<span class="string">"integer"</span> /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">size</span>           //指定大小，一般用在<span class="attr">imageview</span>配合<span class="attr">scaleType</span>属性使用</span></span><br><span class="line"><span class="tag">        <span class="attr">android:width</span>=<span class="string">"integer"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:height</span>=<span class="string">"integer"</span> /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span>          //填充颜色</span></span><br><span class="line"><span class="tag">        <span class="attr">android:color</span>=<span class="string">"color"</span> /&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;<span class="name">stroke</span>         //边框</span></span><br><span class="line"><span class="tag">      <span class="attr">android:width</span>=<span class="string">"integer"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:color</span>=<span class="string">"color"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:dashWidth</span>=<span class="string">"integer"</span>        </span></span><br><span class="line"><span class="tag">        <span class="attr">android:dashGap</span>=<span class="string">"integer"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>* android:shape：默认的shape是矩形，line和ring这两种形状需要通过&lt;stroke&gt;来制定线的宽度和颜色，否则看不到效果。* gradient：solid表示纯色填充，而gradient表示渐变效果。andoid:angle指渐变的角度，默认为0，其值必须是45的倍数，0表示从左到右，90表示从下到上，其他类推。* padding：这个表示的是包含它的view的空白，四个属性分别表示四个方向上的padding值。</code></pre><p>size：ShapeDrawable默认情况下是没有宽高的概念的，但是可以如果指定了size，那么这个时候shape就有了所谓的固有宽高，但是作为view的背景时，shape还是会被拉伸或者缩小为view的大小。</p><ul><li><p>LayerDrawable 对应标签<layer-list>，表示层次化的Drawable集合，实现一种叠加后的效果, 属性android:top/left/right/bottom表示drawable相对于view的上下左右的偏移量，单位为像素。</layer-list></p></li><li><p>StateListDrawable对应 ,可以根据view的状态自动选择drawable,对应标签<selector>，也是表示Drawable集合，每个drawable对应着view的一种状态。</selector></p></li><li><p>LevelListDrawable，对应标签<level-list>，同样是Drawable集合，每个drawable还有一个level值，根据不同的level，LevelListDrawable会切换不同的Drawable，level值范围从0到100000。</level-list></p></li><li>TransitionDrawable标签<transition>，用于实现两个Drawable之间的淡入淡出效果。</transition></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/shape_drawable_gradient_linear"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/shape_drawable_gradient_radius"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">TransitionDrawable drawable = (TransitionDrawable) v.getBackground();</span><br><span class="line">drawable.startTransition(5000);</span><br></pre></td></tr></table></figure><ul><li><p>InsetDrawable标签<inset>，它可以将其他drawable内嵌到自己当中，并可以在四周留出一定的间距。当一个view希望自己的背景比自己的实际区域小的时候，可以采用InsetDrawable来实现。</inset></p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">inset</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:insetBottom</span>=<span class="string">"15dp"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:insetLeft</span>=<span class="string">"15dp"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:insetRight</span>=<span class="string">"15dp"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:insetTop</span>=<span class="string">"15dp"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">shape</span> <span class="attr">android:shape</span>=<span class="string">"rectangle"</span> &gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#ff0000"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">inset</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>ScaleDrawable可以根据level将指定的drawable缩放到一定比例。Level越大，内部drawable看起来也就越大</p></li><li><p>ClipDrawable可以根据自己当前level裁剪另一个drawable。Level越大，裁剪区域越小</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">clip</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:clipOrientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:drawable</span>=<span class="string">"@drawable/image1"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:gravity</span>=<span class="string">"bottom"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>AnimationDrawable可以播放帧动画 </p></li><li>ColorDrawable代表单色</li></ul><h2 id="Drawable自定义"><a href="#Drawable自定义" class="headerlink" title="Drawable自定义"></a>Drawable自定义</h2><ul><li>Drawable的工作核心就是draw方法，所以自定义drawable就是重写draw方法，当然还有setAlpha、setColorFilter和getOpacity这几个方法。当自定义Drawable有固有大小的时候最好重写getIntrinsicWidth和getIntrinsicHeight方法。</li><li>Drawable的内部大小不等于Drawable的实际区域大小，Drawable的实际区域大小可以通过它的getBounds方法来得到，一般来说它和view的尺寸相同。</li></ul>]]></content>
      
      <categories>
          
          <category> Android艺术探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android艺术探索 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Android艺术探索》读书笔记 第七章. Animation</title>
      <link href="/home/2016/08/14/android_art_7_animation/"/>
      <url>/home/2016/08/14/android_art_7_animation/</url>
      <content type="html"><![CDATA[<h2 id="View动画"><a href="#View动画" class="headerlink" title="View动画"></a>View动画</h2><ul><li>建议采用XML定义动画，比代码可读性更好</li><li>android:fillAfter 动画结束以后是否停在结束位置</li><li>自定义View动画需要继承Animation，重写initialize和applyTransformation，在后者进行矩阵变换即可</li><li>帧动画可以通过AnimationDrawable来使用帧动画，也可以通过Handler发消息来替换存在SoftReference里面的ImageView</li></ul><h2 id="View动画特殊场景"><a href="#View动画特殊场景" class="headerlink" title="View动画特殊场景"></a>View动画特殊场景</h2><ul><li>使用LayoutAnimation来给ViewGroup的每个item加上出场效果</li><li>overridingPendingTransition()来改变activity切换的场景，必须在startactivity()和finish()后面调用。Fragment的切换用FragmentTransaction的setCustomAnimations()</li></ul><h2 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h2><ul><li>nineoldandroids动画库在api11以前内部是通过代理View动画来实现的,基本支持所有android系统</li><li>不建议使用xml来实现属性动画，因为在xml中有时候不知道屏幕宽度等</li><li>Interpolator插值器主要来改变动画变化率，TypeEvaluator类型估值器，根据当前属性改变的百分比来计算改变后的属性值</li><li>AnimatorListenerAdapter()有常用回调，AnimatorUpdateListener监听整个动画过程，没播放一帧，回调一次</li><li>对object属性abc做动画条件：<ul><li>1.object必须提供getAbc()和setAbc()方法</li><li>object的setAbc()做的改变通过某种方法UI会改变</li></ul></li><li>属性动画不生效解决办法<ul><li>有权限的话，给你对象加上set和get方法</li><li>用一个类来包装原生对象，间接为其提供get和set方法</li><li>采用ValueAnimator，监听动画过程，自己实现属性改变</li></ul></li><li>属性动画必须运行在有Looper的线程中</li><li>属性动画的核心还是通过反射给每一帧的动画设置属性值</li></ul><h2 id="动画注意事项"><a href="#动画注意事项" class="headerlink" title="动画注意事项"></a>动画注意事项</h2><ul><li>OOM，尽量避免使用帧动画</li><li>属性动画有一类无限循环动画需要在Activity退出时及时停止，View动画不存在这问题</li><li>View动画是对View的影像动画，需要调用clearAnimation()清楚View动画即可</li><li>尽量使用DP</li><li>使用动画的过程中，建议开启硬件加速</li><li>3.0以前不管是View动画还是属性动画，View移动后的事件都无法点击老位置可以.3.0以后,属性动画单机事件随位置移动而移动</li></ul>]]></content>
      
      <categories>
          
          <category> Android艺术探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android艺术探索 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Android艺术探索》读书笔记 第五章. RemoteViews</title>
      <link href="/home/2016/08/13/android_art_5_remoteviews/"/>
      <url>/home/2016/08/13/android_art_5_remoteviews/</url>
      <content type="html"><![CDATA[<h2 id="RemoteView应用"><a href="#RemoteView应用" class="headerlink" title="RemoteView应用"></a>RemoteView应用</h2><ul><li><p>跨进程更新界面，widget和notification都运行在SystemServer进程中</p></li><li><p>单击事件一般通过PendingIntent发广播的方式来实现</p></li><li><p>onEanble()只在第一次添加回调，onDeleted()删除一次回调一次，onDisable()最后一个删除时回调，onUpdate()每次添加或更新时回调</p></li></ul><h2 id="PendingIntent"><a href="#PendingIntent" class="headerlink" title="PendingIntent"></a>PendingIntent</h2><ul><li><p>PendingIntent是即刻发生，Intent是立刻发生.典型场景还是RemoteViews的单机事件</p></li><li><p>PendingIntent支持三种待定意图：启动Activity(getActivity)，启动Service(getService)，发送广播(getBroadcast)</p></li><li><p>PendingIntent 的requestCode相同并且Intent也相同，则证明PendingIntent相同，Intent相同则需要ComponentName和intent-filter相同。</p></li><li><p>PendingIntent 中flags</p><ul><li>FLAG_ONE_SHOT:同类通知只能使用一次，后续单机打开无效</li><li>FLAG_NO_CREATE:没意义</li><li>FLAG_CANCEL_CURRENT: 如果PendingIntent已经存在，都会被cancle，系统创建一个新的，那些被cancel了的将无法打开</li><li>FLAG_UPDATE_CURRENT: 如果PendingIntent已经存在，它们都会被更新，Intent中的Extras被替换成最新的</li></ul></li><li><p>分析NotificationManager.nofify(id, notification) [未测试，看着有点晕]</p><ul><li><p>如果参数id是常量，那么多次调用notify只能弹出一个通知，后续的通知会把前面的通知完全替代掉；</p></li><li><p>如果参数id每次都不同，那么当PendingIntent不匹配的时候，不管采用何种标志位，这些通知之间不会相互干扰；</p></li><li><p>如果参数id每次都不同，且PendingIntent匹配的时候，那就要看标志位：</p></li></ul></li></ul><h2 id="RemoteView内部机制"><a href="#RemoteView内部机制" class="headerlink" title="RemoteView内部机制"></a>RemoteView内部机制</h2><ul><li><p>通知栏和widget布局文件实际上是在NotificationManagerService和AppWidgetService被加载，运行在SystemServer进程中，系统首先将view操作封装到action对象中，并将这些对象跨进程传输到远程进程，远程进程通过RemoteViews的apply方法进行View的更新操作，apply方法会遍历所有action对象来调用它们的apply方法</p></li><li><p>无法使用自定义View，EditText不支持在RemoteView中使用</p></li><li><p>RemoteViews实现了Parcelable接口，它会通过Binder传递到SystemServer进程，系统会根据RemoteViews中的包名信息获取到应用中的资源，从而完成布局文件的加载</p></li><li><p>系统将view操作封装成Action对象，Action同样实现了Parcelable接口，通过Binder传递到SystemServer进程。远程进程通过RemoteViews的apply方法来进行view的更新操作，RemoteViews的apply方法内部则会去遍历所有的action对象并调用它们的apply方法来进行view的更新操作。这样做的好处是不需要定义大量的Binder接口，其次批量执行RemoteViews中的更新操作提高了程序性能。</p></li><li><p>RemoteView的大部分方法都是通过set反射完成</p></li><li><p>RemoteView中，apply加载布局更新界面，reApply只会更新界面</p></li><li><p>setOnClickPendingIntent用于普通view设置单机事件，setPendingIntentTemplate和setOnClickFillInIntent组合使用用于ListView的item点击事件</p></li></ul><h2 id="RemoteView特例"><a href="#RemoteView特例" class="headerlink" title="RemoteView特例"></a>RemoteView特例</h2><ul><li>在两个应用中，用广播的方式完成跨进程通信，通过intent传递remoteviews，来更新另外一个进程的UI，当然RemoteView只能支持一些简单的view。</li></ul>]]></content>
      
      <categories>
          
          <category> Android艺术探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android艺术探索 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Android艺术探索》读书笔记 第四章. View_Principle</title>
      <link href="/home/2016/08/11/android_art_4_viewprinciple/"/>
      <url>/home/2016/08/11/android_art_4_viewprinciple/</url>
      <content type="html"><![CDATA[<h2 id="ViewRoot和DecorView"><a href="#ViewRoot和DecorView" class="headerlink" title="ViewRoot和DecorView"></a>ViewRoot和DecorView</h2><ul><li>ViewRoot 对应于ViewRootImpl，连接的WindowManager和DecorView的纽带，View 三大流程均是通过ViewRoot来完成，ActivityThread中，当Activity对象创建完毕后，将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView关联</li><li>DecorView顶级View，一般情况下包含一个垂直方向的LinearLayout，setContentView布局的确加到了id为content的FrameLayout,DecorView其实是一个FrameLayout，View层的事件先经过DecorView，然后传递我们的View</li></ul><h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h2><ul><li>MeasureSpec 和 LayoutParams对应关系：<ul><li>三类specMode<ul><li>UNSPECIFIED：基本无视；父容器不对View有任何限制，要多大给多大；一般用于系统内部用于测量</li><li>EXACTLY：父容器已经检测出View所需要的大小，View的大小就是SpecSize的值，它对应于LayoutParams中的match_parent和具体的数值</li><li>AT_MOST：父容器指定了一个可用大小即SpecSize，对应于LayoutParams中的warp_content<ul><li>View测量的时候，系统会将LayoutParams在父容器的约束下转换成对应的MeasureSpec，然后根据这个MeasureSpec来确定View测量后的宽高</li><li>MeasureSpec不是唯一由LayoutParams来决定的，LayoutParams需要和父容器一起才能决定View的MeasureSpec，从而进一步确定view的宽高，对于DecorView，它的MeasureSpec由串口的尺寸和其自身的LayoutParams来决定的；对于普通View，它的MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定</li></ul></li></ul></li></ul></li><li>普通View的MeasureSpec创建规则：<ul><li>当View采取固定宽高时，不管父容器MeasureSpec是什么，View的MeasureSpec都是精确模式，并且大小是LayoutParams中的大小</li><li>当View的宽高是match_parent时，如果父容器模式是精确模式，那么View的模式也是精确模式，大小是父容器的剩余空间，如果父容器是最大模式，那么view也是最大模式，大小不超过父容器剩余空间</li><li>View的宽高是wrap_content时，不管父容器的模式是精确模式还是最大模式，View的模式总是最大模式，大小不超过父容器剩余空间</li></ul></li></ul><h2 id="View的工作原理"><a href="#View的工作原理" class="headerlink" title="View的工作原理"></a>View的工作原理</h2><ul><li>measure过程<ul><li>getSuggestedMinimumWidth，如果没有设置背景，返回android:minWidth的值，可以为0；View设置了背景，返回android:minWidth和背景最小宽度两证的最大值。getSuggestedMinimumWidth/Height返回值就是View在UNSPECIFIED情况下的测量宽高</li><li>获取View宽高方式：<ul><li>Activity/View 的onWindowFocusChanged()获取焦点或者焦点改变都要调用，onPause(),onResume()执行也要多次调用</li><li>View.post(runnable)</li><li>ViewTreeObserver的OnGlobalLayoutListener接口，也要注意多次调用，记得removeListener()</li><li>通过View.measure(int widthMeasureSpec,int heightMeasureSpec),不推荐</li></ul></li></ul></li><li>layout过程<ul><li>一般在onLayout()中去获取测量的宽高，得到的才是准确的</li><li>getMeasureWidth()和getWidth()区别：最终值是相等的，第一个形成于measure过程，第二个形成于layout过程，两者赋值时机不同</li></ul></li><li>draw过程<ul><li>绘制背景background.draw(canvas);</li><li>绘制自己ondraw();</li><li>绘制子ViewdispatchDraw();</li><li>绘制装饰onDrawScrollBars();</li></ul></li></ul><h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><ul><li>让View支持wrap_content</li><li>让View支持padding</li><li>View本身提供post方法，最好不要用handler</li><li>在onDetachedFromWindow()方法回调中停止线程和动画</li><li>注意viewgroup的padding以及子元素的margin</li><li>View带有滑动嵌套的情况要处理好滑动冲突    </li></ul>]]></content>
      
      <categories>
          
          <category> Android艺术探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android艺术探索 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Android艺术探索》读书笔记 第三章. View_Event</title>
      <link href="/home/2016/08/05/android_art_3_viewevent/"/>
      <url>/home/2016/08/05/android_art_3_viewevent/</url>
      <content type="html"><![CDATA[<h2 id="View基础"><a href="#View基础" class="headerlink" title="View基础"></a>View基础</h2><ul><li>位置坐标<ul><li>View在平移过程中，top和left是原始左上角的位置信息，其值不会改变，发送改变的是x，y(View左上角的坐标)，translationX和translationY(View左上角相对于父容器便宜量)</li></ul></li><li>MotionEvent<ul><li>点击View产生x，y，而getX/getY返回相对于当前View左上角x和y的坐标，getRawX/getRawY返回的是相对屏幕设计左上角x和y坐标</li></ul></li><li>TouchSlop<ul><li>系统认定滑动最小常量：ViewConfiguration.get(getContext()).getScaledTouchSlop().源码中找到有8dp</li></ul></li><li>VelocityTracker(速度追踪)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在View的OnTouchEvent()方法中追踪手指滑动速度</span></span><br><span class="line">VelocityTracker tracker = VelocityTracker.obtain();</span><br><span class="line">tracker.addMovement(event);</span><br><span class="line">tracker.computeCurrentVelocity(<span class="number">1000</span>);<span class="comment">//滑动时间间隔</span></span><br><span class="line"><span class="keyword">int</span> xVelocity = (<span class="keyword">int</span>)tracker.getXVelocity();</span><br><span class="line"><span class="keyword">int</span> yVelocity = (<span class="keyword">int</span>)tracker.getYVelocity();</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后在不需它的时候clear重置回收内存</span></span><br><span class="line">tracker.clear();</span><br><span class="line">tracker.recycle();</span><br></pre></td></tr></table></figure><ul><li>GestureDetector(手势检测)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line">GestureDetector mGestureDetector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>);</span><br><span class="line">mGestureDetector.setIsLongPressEnabled(<span class="keyword">false</span>);<span class="comment">//解决长按屏幕后无法拖动的现象</span></span><br><span class="line"><span class="comment">//2.实现OnGestureListener接口</span></span><br><span class="line"><span class="comment">//3.接管目标View的onTouchEvent方法</span></span><br><span class="line"><span class="keyword">boolean</span> consume =  mGestureDetector.onTouchEvent(event);</span><br><span class="line"><span class="keyword">return</span> consume;</span><br></pre></td></tr></table></figure><ul><li>onFling(快速华东和)</li><li>建议监听滑动相关自己在onTouchEvent中实现，监听双击行为可以使用GesureDetector<ul><li>Scroller(弹性滑动)</li></ul></li><li>scrollTo/scollBy瞬间完成，可以通过scroller.startScroll和computeScroll配合使用完成弹性滑动</li></ul><h2 id="View滑动"><a href="#View滑动" class="headerlink" title="View滑动"></a>View滑动</h2><ul><li>scrollBy基于当前位置的相对滑动，scrollTo是基于参数的绝对滑动。</li><li>scrollBy和scrollTo只能改变内容的位置不能改变View在布局中的位置 </li></ul><h2 id="View弹性滑动"><a href="#View弹性滑动" class="headerlink" title="View弹性滑动"></a>View弹性滑动</h2><ul><li>Scroller工作原理：scroller本身不能让View进行滑动，需要View的computeScroll方法才能完成弹性滑动的效果，不断让View重绘，每次滑动距起始时间有一个时间间隔，通过间隔可以得出View当前的滑动位置，然后就可以通过srollTo完成view的滑动，这样不断重绘，不断滑动。</li></ul><h2 id="View事件分发"><a href="#View事件分发" class="headerlink" title="View事件分发"></a>View事件分发</h2><h3 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h3><blockquote><p>解析：一个ViewGroup，点击事件产生后，首先传递给它，它的dispatchTouchEvent()会被首先调用，如果它的onIntercepterTouchEvent()返回true，表示事件交给ViewGroup处理，它的onTouchEvent()方法会被调用;如果返回false就表示不拦截当前事件，事件传递给子元素，子元素的dispatchTouchEvent()会被调用  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(onIntercepterTouchEvent(ev))&#123;</span><br><span class="line">  consume = onTouchEvent(ev);</span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">  consume = child.dispatchTouchEvent(ev);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给View设置OnTouchListener，其优先级比onTouchEvent要高，而onClickListener优先级最低，事件传递尾端</li><li>如果一个view的onTouchEvent()返回false，父容器onTouchEvent()会被调用，如果所有元素都不处理事件，就交给activity的onTouchEvent()</li><li>某个View一旦开始处理某个事件，这个事件的序列都只有它来处理，并且它的onInterceptTouchEvent不再被调用</li><li>View的onTouchEvent()默认消耗此事件，返回true,除非同时设置clickable和longclickable同时为false。View的enable属性不影响onTouchEvent返回值，哪怕一个view是disable的状态，只要clickable和longclickable有一个为true，onTouchEvent就会返回true消耗此事件</li><li>事件传递是由外向内，即事件总是先传递给父元素，然后由父元素分发给子view</li></ul><h3 id="事件分发源码解析"><a href="#事件分发源码解析" class="headerlink" title="事件分发源码解析"></a>事件分发源码解析</h3><ul><li>Activity对点击事件分发过程<ul><li>首先事件开始交给Activity所属的Window进行分发，返回true，循环结束，false没人处理，所有View的onTouchEvent都返回false，Activity的onTouchEvent就会被调用。</li><li>Window的实现类PhoneWindow通过过superDispatchTouchEvent将事件直接传递给了DecorView(一般就是当前页面的底层容器，即setContentView所设置的父容器，可以通过getWindow().getDecorView()获得)</li><li>由于DecorView继承自FrameLayout且是父View，所以最终事件会传递给View，顶级View一般是ViewGroup。得到Activity所设置的View方式：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>顶级View对事件分发过程<ul><li>事件到达顶级View(一般是ViewGroup)，会调用ViewGroup的dispatchTouchEvent方法，如果顶级ViewGroup拦截事件，即onInterceptTouchEvent返回true，事件由ViewGroup进行处理。这时如果monTouchListener被设置，onTouch会被调用，否则onTouchEvent会被调用，都提供的话onTouch会屏蔽掉onTouchEvent。onTouchEvent中，设置了mOnClickListener，则onClikc会被调用。如果顶级ViewGroup不拦截事件，则事件会传递给它所在点击事件的子View，子View的dispatchTouchEvent会被调用。</li><li>事件传递过程总是先传递给父元素，然后再由父元素分发给子view，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外，即当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的onInterceptTouchEvent方法来询问自己是否要拦截事件。ViewGroup的dispatchTouchEvent方法中有一个标志位FLAG_DISALLOW_INTERCEPT，这个标志位就是通过子view调用requestDisallowInterceptTouchEvent方法来设置的，一旦设置为true，那么ViewGroup不会拦截该事件,子View调用request-DisallowInterceptTouchEvent方法并不能影响ViewGroup对ACTION_DOWN事件的处理<ul><li>便利ViewGroup所有子元素，然后判断子元素是否能够接收到点击事件，由两点判断，子元素是否在播放动画和点击事件的坐E标是否落在子元素区域内。满足两个条件，事件传递给它处理，如果子元素dispatchTouchEvent返回true，暂时不考虑子元素内部怎么分发的，子元素dispatchTouchEvent返回false，就把事件发给下一个子元素。</li></ul></li></ul></li><li>View对点击事件处理过程<ul><li>onTouchListener的优先级高于onTouchEvent，View处于不可用状态下点击事件照样会被消耗</li><li>当ACTION_UP事件发生时，会触发performClick方法，如果设置了OnClickListener，会回调onCLick</li><li>View的LONG_CLICKABLE属性默认为false，而CLICKABLE属性是否为false和view有关，可点击的View(Button)其CLICKABLE为true，不可点击的View(TextView)其CLICKABLE为false。setOnClickListener和setOnLongClickListener分别改变其默认值为true</li></ul></li></ul><h2 id="View滑动冲突"><a href="#View滑动冲突" class="headerlink" title="View滑动冲突"></a>View滑动冲突</h2><ul><li>滑动冲突的场景<ul><li>外部滑动方向和内部滑动方向不一致</li><li>外部滑动方向和内部滑动方向一致</li><li>上面情况的嵌套</li></ul></li><li><p>处理规则</p><ul><li>可以根据滑动距离和水平方向形成的夹角；或者根绝水平和竖直方向滑动的距离差；或者两个方向上的速度差等</li></ul></li><li><p>外部拦截法(点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要就不拦截。该方法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可，其他均不需要做修改。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">            intercepted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> deltaX = x - mLastXIntercept;</span><br><span class="line">            <span class="keyword">int</span> deltaY = y - mLastYIntercept;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY))&#123;</span><br><span class="line">                intercepted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            intercepted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLastXIntercept = x;</span><br><span class="line">    mLastYIntercept = y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内部拦截法（父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此件就直接消耗掉，否则就交给父容器来处理。这种方法和Android中的事件分发机制不<br>一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作，重写<br>子元素的dispatchTouchEvent方法）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子元素的修改</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">    <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;]</span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">            <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">            <span class="keyword">if</span> (当前view需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY))&#123;</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父元素修改，为什么父容器不能拦截ACTION_DOWN事件？</span></span><br><span class="line"><span class="comment">//因为ACTION_DOWN不受FLAG_DISALLOW_INTERCEPT这个标记位控制，所以一旦父容器拦截DOWN事件，所有事件无法传递到子元素中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android艺术探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android艺术探索 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Android艺术探索》读书笔记 第二章. IPC</title>
      <link href="/home/2016/08/01/android_art_2_ipc/"/>
      <url>/home/2016/08/01/android_art_2_ipc/</url>
      <content type="html"><![CDATA[<h2 id="IPC-简介"><a href="#IPC-简介" class="headerlink" title="IPC 简介"></a>IPC 简介</h2><ul><li>线程是CPU调度的最小单元</li><li>IPC指进程间通信，Binder是Android中特色的进程间通信方式</li></ul><h2 id="Android中的多进程"><a href="#Android中的多进程" class="headerlink" title="Android中的多进程"></a>Android中的多进程</h2><ul><li><p>Android多进程的启动</p><ul><li>给四大组件设置指定android:process = “:remote”属性启动多进程</li><li>进程以:开头属于当前应用的私用进程，其他应用的组件不可以和它跑在同一个进程中，进程名不以:开头进程属于全局进程，其他应用通过shareUID可以和他跑在同一个进程，两个应用通过ShareUID跑在一个进程除了uid要一致还要签名一致。</li></ul><blockquote><p>Android 在多进程中通过内存共享数据，都会失败，在多进程模式中，不同进程的组件会有不同的虚拟机，不同的内存空间以及不同的Application.</p></blockquote></li><li>Android多进程带来的问题<ul><li>静态成员或者单例模式失效</li><li>线程同步机制失效</li><li>SharedPreference的读写XML可靠性下架</li><li>Application会多次创建</li></ul></li></ul><h2 id="Android中IPC基础概念"><a href="#Android中IPC基础概念" class="headerlink" title="Android中IPC基础概念"></a>Android中IPC基础概念</h2><ul><li>序列化和反序列化<ul><li>静态成员变量属于类不属于对象，所以不能序列化，用transient修饰的成员变量也不能序列化</li><li>序列化前和序列化后对象内容相同，但是产生了两个对象</li><li>Serializable是java序列化接口，用I/O操作，开销大，使用简单。Parcelable是Android序列化接口，用在内存序列化上，通过Parcelable将对象序列化到设备中或者序列化后网络传输，推荐，使用麻烦。</li></ul></li><li><code>-</code>Binder<ul><li>Binder 首先内部两个整形ID标记这两个方法，然后这两个id用于表示在transact过程中客户端到底是哪个方法，接着声明一个内部类Stub，这个内部类就是一个Binder类，客户端位于同一进程不走跨进程的transact方法，反之，这个逻辑有Proxy完成，Binder内部采用的是代理-存根的设计模式</li><li>客户端通过IBinder.DeathRecipient来监听Binder死亡，也可以在onServiceDisconnected中监听并重连服务端。区别在于前者是在binder线程池中，访问UI需要用Handler，后者则是UI线程。</li><li>工作机制：<br><img src="Binder.png" alt="image"></li></ul></li></ul><h2 id="Android-IPC的方式"><a href="#Android-IPC的方式" class="headerlink" title="Android IPC的方式"></a>Android IPC的方式</h2><ul><li>Bundle：因为实现了Parcelable接口，所以可以在不同进程间进行传输</li></ul><ul><li>文件共享： <ul><li>采用序列化和反序列化得方式读写文件，可以进行进程间通讯，只是要处理并发读/写的问题。</li><li>采用SharedPreference：读/写有一定的缓存策略，内存中会存有，很大几率丢失。不建议。</li></ul></li></ul><ul><li>Messenger：是AIDL的一次封装，而且一次只能处理一个请求，不能处理并发消息，因此服务端不用考虑线程同步的问题。</li></ul><ul><li>AIDL：<ul><li>AIDL使用流程：首先创建一个Service和一个AIDL接口，接着创建一个类继承自AIDL借口中的Stub类并且实现Stub类的抽象方法，在service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端的service，建立连接后就可以远程访问服务端了.</li><li>服务端可以使用CopyOnWriteArrayList和ConcurrentHashMap来进行自动线程同步，客户端拿到的依然是ArrayList和HashMap；</li><li>可通过自定义权限在onBind或者onTransact中进行权限验证</li></ul></li><li>ContentProvider:<ul><li>ContentProvider 底层的实现同样是Binder</li><li>自定义一个继承ContentProvider，六个抽象方法中，onCreate()是运行在主线程中，其余的是运行在Binder线程中</li><li>在android.manifest里面注册provider的时候指定android:authorities标识，可以让外部应用访问这个组件</li><li>ContentProvider 操作数据库的时候增删改查四大方法是存在多线程并发的，方法内部需做好线程同步访问，SQLite只有一个SQLiteDatabase的连接，可以应对多线程的情况，因为SQLiteDatabase内部对数据库操作有做同步，多个数据库对象就没法进行线程同步。</li></ul></li><li>Socket:<ul><li>TCP协议是面向连接的协议，提供稳定的双向通信功能，有三次握手，稳定，提供重传机制；UDP无连接，不稳定单项连接功能，更高效率，但是数据不一定正确传输</li><li>IP地址可见，可以实现设备之间的通讯，类似与助手类软件的免流量分享功能</li></ul></li><li>Binder连接池： <ul><li>工作机制：每个业务模块创建自己的AIDL接口并实现这个接口，不同业务模块之间不能拿有耦合的情况，单独开来，然后向服务端提供自己的唯一标识和其对应的binder对象；服务端只需要一个service，提供一个查询querybinder接口，根据业务特征返回binder对象，不同业务模块拿到自己的Binder对象就可以远程方法调用了，避免service的创建。</li><li>这里用到了CountDownLatch，大概解释下用意：线程在await后等待，直到CountDownLatch的计数为0，BinderPool里使用它的目的是为了保证Activity获取BinderPool的时候Service已确定bind完成～</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> Android艺术探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android艺术探索 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Android艺术探索》读书笔记 第一章.Activity</title>
      <link href="/home/2016/07/25/android_art_1_activity/"/>
      <url>/home/2016/07/25/android_art_1_activity/</url>
      <content type="html"><![CDATA[<h2 id="LifeCyle生命周期"><a href="#LifeCyle生命周期" class="headerlink" title="LifeCyle生命周期"></a>LifeCyle生命周期</h2><ul><li>正常情况<ul><li>onCreate –&gt; onStart –&gt; onResume –&gt; 运行–&gt; 按返回键结束程序–&gt; onPause–&gt;onStop–&gt;onDestory</li><li>Activity切换时，旧Activity的onPause会先执行，然后才会启动新的Activity</li><li>Activity在异常情况下被回收时，onSaveInstanceState方法会被回调，回调时机是在onStop之前，当Activity被重新创建的时 候，onRestoreInstanceState方法会被回调，时序在onStart之后；</li></ul></li></ul><ul><li>异常情况<ul><li>资源相关的系统配置发生改变 ：像横竖屏切换，Activity销毁并重建，onPause,onStop,onDestory均会调用，系统调用onSaveInstanceState来保存当前Activity状态。这个方法是在onStop之前，当Activity重建的时候系统会把onSaveInstanceState所保存的Bundle作为对象传递给onRestoreInstanceState和onCreate方法。</li><li>资源内存不足导致低优先级Activity被杀死 : 系统内存不足时，会按照以上顺序杀死Activity，并通过onSaveInstanceState和onRestoreInstanceState这两个方法来存储和恢复数据。</li></ul></li></ul><h2 id="LaunchMode启动模式"><a href="#LaunchMode启动模式" class="headerlink" title="LaunchMode启动模式"></a>LaunchMode启动模式</h2><ul><li>启动模式<ul><li>standard ：标准模式。每次启动会重新创建新的实例，谁启动了这个Activity，这个Activity就在谁的栈里。</li><li>singleTop ：栈顶复用模式。新Activity位于栈顶，Activity不会被重新创建，该Activity的onNewIntent方法会被回调，onCreate和onStart并不会被调用。</li><li>singleTask ：栈内复用模式(单实例模式)。只要该Activity在一个栈中存在，都不会重新创建，onNewIntent会被回调。如果不存在，系统会先寻找是否存在需要的栈，如果不存在该栈，就创建一个任务栈，然后把这个Activity放进去；如果存在，就会创建到已经存在的这个栈中。(D的任务栈为S1，S1的任务栈为ADBC)，singleTask默认具有cleartTop的效果，会导致D上面所有的出站，最终为AD。</li><li>singleInstance ：加强单实例模式。具有此种模式的Activity只能单独存在于一个任务栈。</li></ul></li></ul><ul><li>TaskAffinity ：任务相关性，不能和包名相同，一般主要和singleTask启动模式或者allowTaskReparenting配对使用.</li><li>Flags：FLAG_ACTIVITY_CLEAR_TOP一般和singleTask启动模式一起出现。同一栈中为与它上Activity都要出栈。</li></ul><h2 id="IntentFilter匹配规则"><a href="#IntentFilter匹配规则" class="headerlink" title="IntentFilter匹配规则"></a>IntentFilter匹配规则</h2><ul><li>匹配规则<ul><li>action匹配规则 : 可以有多个action，要求intent中的action存在且必须和过滤规则中的其中一个相同区分大小写；</li><li>category匹配规则 : 系统会默认加上一个android.intent.category.DEAFAULT，所以intent中可以不存在category，但如果存在就必须匹配其中一个；</li><li>data匹配规则 : 要求和action相似，如果规则定义data，Intent也必须定义可以匹配的。</li></ul></li></ul><ul><li>data : data由两部分组成，mineType和URI。mineType类型，比如image/jpeg、audio/mpeg4-generic和video/*</li><li>URI : [scheme]://[host]:[port]/[path]- tips:path中“*”要写成“\\*”,”\“要写成“\\\\”</li><li>如果要为Intent指定完整的data，必须要调用setDataAndType方法，不能分别调用setData和setType因为会分别至空值</li><li>通过隐式方法启动Activity的时候一定要判断空，看是否有Activity匹配我们的Intent，判断方法为：PackageManager的resolveActivity或者Intent的resolveActivity.</li></ul>]]></content>
      
      <categories>
          
          <category> Android艺术探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android艺术探索 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>个人简介</title>
      <link href="/home/about/index.html"/>
      <url>/home/about/index.html</url>
      <content type="html"><![CDATA[<p>大家好，我是Rocka，欢迎来到我的个人技术博客。本人热爱技术，热爱音乐，热爱潮流。</p><p>本博客主要是自我总结归纳，读书笔记，编程技术的心得体会。</p><h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><table><thead><tr><th style="text-align:left">工作时间</th><th style="text-align:center">工作单位</th><th style="text-align:right">工作描述</th></tr></thead><tbody><tr><td style="text-align:left">2011.6 - 2012.6</td><td style="text-align:center">成都梦想兄弟</td><td style="text-align:right">Android游戏移植与游戏开发</td></tr><tr><td style="text-align:left">2012.6 - 2013.6</td><td style="text-align:center">国腾软资</td><td style="text-align:right">国腾软件旗下APP与网站开发</td></tr><tr><td style="text-align:left">2013.6 - 2015.6</td><td style="text-align:center">百度91无限事业部</td><td style="text-align:right">91旗下APP开发</td></tr><tr><td style="text-align:left">2015.7 - 至今</td><td style="text-align:center">当乐网</td><td style="text-align:right">当乐网旗下APP开发</td></tr></tbody></table><h3 id="现在-amp-未来"><a href="#现在-amp-未来" class="headerlink" title="现在&amp;未来"></a>现在&amp;未来</h3><ul><li>现在主要从事的Android APP开发，未来希望抽出时间学习人工智能方向。</li></ul>]]></content>
    </entry>
    
    <entry>
      <title>读书</title>
      <link href="/home/reading/index.html"/>
      <url>/home/reading/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
